<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Command Line Applications in Rust</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="src/special-content.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="README_zh.html">让我们开始吧！</a></li><li class="chapter-item expanded "><a href="tutorial/README_zh.html"><strong aria-hidden="true">1.</strong> 15 分钟编写一个命令行工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/setup_zh.html"><strong aria-hidden="true">1.1.</strong> 初始化项目</a></li><li class="chapter-item expanded "><a href="tutorial/cli-args_zh.html"><strong aria-hidden="true">1.2.</strong> 解析命令行参数</a></li><li class="chapter-item expanded "><a href="tutorial/impl-draft_zh.html"><strong aria-hidden="true">1.3.</strong> 第一个实现</a></li><li class="chapter-item expanded "><a href="tutorial/errors_zh.html"><strong aria-hidden="true">1.4.</strong> 更好地反馈错误</a></li><li class="chapter-item expanded "><a href="tutorial/output_zh.html"><strong aria-hidden="true">1.5.</strong> 输出</a></li><li class="chapter-item expanded "><a href="tutorial/testing_zh.html"><strong aria-hidden="true">1.6.</strong> 测试</a></li><li class="chapter-item expanded "><a href="tutorial/packaging_zh.html"><strong aria-hidden="true">1.7.</strong> 打包并发布一个 Rust 工具</a></li></ol></li><li class="chapter-item expanded "><a href="in-depth/README_zh.html"><strong aria-hidden="true">2.</strong> 再深入谈谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="in-depth/signals_zh.html"><strong aria-hidden="true">2.1.</strong> 信号处理</a></li><li class="chapter-item expanded "><a href="in-depth/config-files_zh.html"><strong aria-hidden="true">2.2.</strong> 使用配置文件</a></li><li class="chapter-item expanded "><a href="in-depth/exit-code_zh.html"><strong aria-hidden="true">2.3.</strong> 退出状态码</a></li><li class="chapter-item expanded "><a href="in-depth/human-communication_zh.html"><strong aria-hidden="true">2.4.</strong> 与人交互</a></li><li class="chapter-item expanded "><a href="in-depth/machine-communication_zh.html"><strong aria-hidden="true">2.5.</strong> 与机器交互</a></li><li class="chapter-item expanded "><a href="in-depth/docs_zh.html"><strong aria-hidden="true">2.6.</strong> 为你的 CLI 程序生成文档</a></li></ol></li><li class="chapter-item expanded "><a href="crates/README_zh.html"><strong aria-hidden="true">3.</strong> 好用的 crates</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-cli/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-中的命令行应用"><a class="header" href="#rust-中的命令行应用">Rust 中的命令行应用</a></h1>
<p>Rust 是一种静态编译的、运行速度快的语言，它拥有强大的工具，且其生态也在快速发展。
这使得它非常适合编写命令行应用：小巧、便携且运行速度快。
而命令行应用也是开始进行 Rust 学习，或向你的团队介绍 Rust 的一种很好的方式。</p>
<p>编写一个简单的命令行界面程序（CLI）对于刚接触 Rust 且希望对其有所了解的初学者来说，
是一个很好的练习。不过，这里面也包含了许多方面，后面我们会介绍到它们。</p>
<p>本书的大纲如下：
首先我们从一个快速教程开始，完成后你将得到一个可用的 CLI 工具。通过此教程，
你将接触到 RUST 的一些核心概念及 CLI 应用的主要包括了哪些部分功能。
而下面的章节则是介绍这些方面的实现细节。</p>
<p>最后，也是非常重要的一件事：如果在本书发现了错误，或是想贡献、丰富本书的内容，
项目源码在这里 <a href="https://github.com/rust-cli/book">in the CLI WG repository</a> ，期待你的反馈！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-分钟编写一个命令行应用来学习-rust"><a class="header" href="#15-分钟编写一个命令行应用来学习-rust">15 分钟编写一个命令行应用来学习 Rust</a></h1>
<p>本教程将引导你使用 <a href="https://rust-lang.org/">Rust</a> 编写 CLI（命令行界面）应用。
只需 15 分钟即可让你得到一个可正常运行的程序（大概 1.3 章之前）。
之后我们将继续调整程序，直到它可以被当作一个工具来发布。</p>
<p>你将学到如何开始所需的所有基本知识，及如何去寻找更多有用信息。
当然，你可随意跳过当前你不需要了解的章节，或之后再翻回查看。</p>
<aside>
<p><strong>先决条件：</strong>
本教程并不能替代编程的一般性介绍，你最好了解、熟悉一些常见的概念。
同样，你应该可以熟练的使用命令行或终端。如果你会使用其它的语言，
那么这对于你接触，学习 Rust 会很有帮助。 </p>
<p><strong>获取帮助：</strong>
如果你在任何时候对所使用的功能感到不解或困惑，请查阅 Rust 提供的官方文档，
首先是这本《The Rust Programming Language》。一般安装 Rust 时也会安装它
（<code>rustup doc</code>），或者你也可以在线查看 <a href="https://doc.rust-lang.org">doc.rust-lang.org</a>。</p>
<p>也非常欢迎你来社区提问——Rust 社区以友好和乐于助人著称。
在<a href="https://www.rust-lang.org/community">社区页面</a>你可以看到人们关于 Rust 的讨论的列表。
You are also very welcome to ask questions –</p>
</aside>
<p>你想要写一个什么样的项目呢？不如我们先从一个简单的开始吧：让我们写一个简单的
<code>grep</code>。我们给这个工具一个字符串和一个文件路径，它将打印出每个包含所查字符串的行。
不如就叫它 <code>grrs</code> 吧。</p>
<p>最后，我们想让它像这样工作：</p>
<pre><code class="language-console">$ cat test.txt
foo: 10
bar: 20
baz: 30
$ grrs foo test.txt
foo: 10
$ grrs --help
[some help text explaining the available options]
</code></pre>
<aside class="note">
<p><strong>注意：</strong>
本书是基于 <a href="https://doc.rust-lang.org/edition-guide/index.html">Rust 2018</a> 来创作的，同时，这些代码同样适用于 Rust 2015，
只需做一点点调整，例如添加上 <code>extern crate foo</code> 声明。</p>
<p>确保你运行的是 Rust 1.31.0（或更高版本），同时在你的 <code>Cargo.toml</code> 文件中，
在 <code>[package]</code> 段添加上 <code>edition = &quot;2018&quot;</code>。</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开始项目"><a class="header" href="#开始项目">开始项目</a></h1>
<p>首先在你的电脑上<a href="https://www.rust-lang.org/tools/install">安装 Rust</a>（如果还没有，这只需大概几分钟）。
然后，打开终端，切换到你的工作目录，程序源码将放置在这里。</p>
<p>在你的工作目录里，运行 <code>cargo new grrs</code> 来生成软件项目。
进入 <code>grrs</code> 目录，你会看到典型的 Rust 项目目录结构：</p>
<ul>
<li><code>Cargo.toml</code> 里包含了我们项目所有的元数据，包括我们使用依赖/外部库列表。</li>
<li><code>src/main.rs</code> 是我们程序的二进制入口文件（主程序）。</li>
</ul>
<p>在 <code>grrs</code> 目录下执行 <code>cargo run</code>，若程序打印出 <code>Hello World</code>，那就大功告成了！</p>
<h2 id="它应该是这样的"><a class="header" href="#它应该是这样的">它应该是这样的</a></h2>
<pre><code class="language-console">$ cargo new grrs
     Created binary (application) `grrs` package
$ cd grrs/
$ cargo run
   Compiling grrs v0.1.0 (/Users/pascal/code/grrs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/grrs`
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解析命令行参数"><a class="header" href="#解析命令行参数">解析命令行参数</a></h1>
<p>我们的 CLI 工具的调用方法应该如下：</p>
<pre><code class="language-console">$ grrs foobar test.txt
</code></pre>
<p>我们希望此程序将查找 <code>test.txt</code> 并打印出包含 <code>foobar</code> 的行。
但我们如何获取这个两个值呢？</p>
<p>命令行中，程序名中后面的文本通常被称为“命令行参数”或“命令行标识”（比如 --this）。
操作系统通常会将它们识别为字符串列表——简单的说，以空格分隔。</p>
<p>有很多方法可以识别这些参数，解析，使它们变得更为易于使用。同时，也需要告诉用户，
程序需要哪些参数及对应的格式是什么。</p>
<h2 id="获取参数"><a class="header" href="#获取参数">获取参数</a></h2>
<p>标准库中提供的 <a href="https://doc.rust-lang.org/1.39.0/std/env/fn.args.html"><code>std::env::args()</code></a> 方法，提供了运行时给定参数的<a href="https://doc.rust-lang.org/1.39.0/std/iter/index.html">迭代器</a>。
第一项（索引0）是程序名（如 <code>grrs</code>），后面的即才是用户给定的参数。</p>
<p>以此方法获取原始参数就是这么简单（在 <code>src/main.rs</code> 的 <code>fn main()</code> 函数中）：</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
</code></pre>
<h2 id="cli-参数的数据类型"><a class="header" href="#cli-参数的数据类型">CLI 参数的数据类型</a></h2>
<p>与其将它们视为单纯的一堆文本，不如将 CLI 参数看成程序输入的自定义的数据类型。</p>
<p>注意 <code>grrs foobar test.txt</code>：这里有两个参数，首先是 <code>pattern</code>（查看的字符串），
而后是 <code>path</code>（查找的文件路径）。</p>
<p>那么，关于这些参数，首先，这两个参数都是程序所必须的，因为我们并未提供默认值，
所以用户需要在使用此程序时提供这两个参数。此外，关于参数的类型：<code>pattern</code>
应该是一个字符串；第二个参数则应是文件的路径。</p>
<p>在 Rust 中，根据所处理的数据去构建程序是很常见的，
因此这种看待参数的方法对我们接下来的工作很有帮助，让我们以此开始
（在 <code>src/main.rs</code>，<code>fn main()</code> 之前）：</p>
<pre><code class="language-rust ignore">struct Cli {
    pattern: String,
    path: std::path::PathBuf,
}

</code></pre>
<p>这定义了一个新的，存储了 <code>pattern</code> 和 <code>path</code> 两项数据的结构体(<a href="https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html"><code>struct</code></a>)。</p>
<aside>
<p><strong>注：</strong>
<a href="https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html"><code>PathBuf</code></a> 是可跨平台使用的系统路径类型，特性类似于 <a href="https://doc.rust-lang.org/1.39.0/std/string/struct.String.html"><code>String</code></a>。</p>
</aside>
<p>我们并没有获得程序运行所需的参数，而这正是现在需要去做的。
一种做法是，我们可以手动解析从系统获取的参数列表并以此生成一个结构体，像这样：</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
let args = Cli {
    pattern: pattern,
    path: std::path::PathBuf::from(path),
};
</code></pre>
<p>这种方式能正常工作，用起来却不是很方便。如何去满足像 <code>--pattern=&quot;foo&quot;</code> 或
<code>--pattern &quot;foo&quot;</code> 这种参数输入？又如何实现 <code>--help</code>？</p>
<h2 id="使用-structopt-解析-cli-参数"><a class="header" href="#使用-structopt-解析-cli-参数">使用 StructOpt 解析 CLI 参数</a></h2>
<p>使用现成的库来实现参数的解析，这是更明智的选择。
<a href="https://clap.rs/"><code>clap</code></a> 是当前最受欢迎的解析命令行参数的库。它提供了所有你需要的功能，
如子命令、自动补全和完善的帮助信息。</p>
<p><a href="https://docs.rs/structopt"><code>structopt</code></a> 库基于 <code>clap</code>，并提供了一个“派生”宏来为结构体生成 <code>clap</code> 代码。
这可太棒了：我们只需要去声明一个结构体，它就会生成将参数解析为结构体字段的代码！</p>
<p>首先，我们需要在 <code>Cargo.toml</code> 文件的 <code>[dependencies]</code> 字段里添加上
<code>structopt = &quot;0.3.13&quot;</code> 来导入 <code>structopt</code>。</p>
<p>现在，在我们的代码中，导入，<code>use structopt::StructOpt</code>，在之前创建的
<code>struct Cli</code> 的正上方添加上 <code>#[derive(StructOpt)]</code>，并顺便写一些文档注释。</p>
<p>它现在看起来是这样的：</p>
<pre><code class="language-rust ignore">use structopt::StructOpt;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(StructOpt)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    #[structopt(parse(from_os_str))]
    path: std::path::PathBuf,
}

</code></pre>
<aside class="node">
<p><strong>注意：</strong>
你可以将许多自定义属性添加到字段中。例，我们告诉了 strcutopt 如何解析 <code>PathBuf</code>。
如果你想将 <code>-o</code> 或 <code>--output</code> 后的参数解析为某个字段，可在字段上方添加上
<code>#[structopt(short = &quot;o&quot;, long = &quot;output&quot;)]</code>。更多属性设置，请查看
<a href="https://docs.rs/structopt">structopt documentation</a>。</p>
</aside>
<p>本例中，在我们的 <code>Cli</code> 结构体下方即是 <code>main</code> 函数。
当运行程序时，就会调用这个函数，第一行如下：</p>
<pre><code class="language-rust ignore">fn main() {
    let args = Cli::from_args();
}
</code></pre>
<p>这将尝试解析参数并存储到 <code>Cli</code> 结构体中。</p>
<p>但如果解析失败会怎样？这就是使用此方法的美妙之处：Clap 知道它需要什么字段，
及所需字段的类型。它可以自动生成一个不错的 <code>--help</code> 信息，
并会依错误给出一些建议——输入的参数应该是 <code>--output</code> 而你输入的是 <code>--putput</code>。</p>
<aside class="note">
<p><strong>注意：</strong>
<code>from_args</code> 方法应该在 <code>main</code> 函数中使用。在它失败后会立即退出并打印错误信息。
请不要在其它地方使用它！</p>
</aside>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h2>
<p>你的代码现在看起来应该是这样的：</p>
<pre><code class="language-rust ignore">#![allow(unused)]

use structopt::StructOpt;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(StructOpt)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    #[structopt(parse(from_os_str))]
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::from_args();
}
</code></pre>
<p>无参数运行时：</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 10.16s
     Running `target/debug/grrs`
error: The following required arguments were not provided:
    &lt;pattern&gt;
    &lt;path&gt;

USAGE:
    grrs &lt;pattern&gt; &lt;path&gt;

For more information try --help
</code></pre>
<p>我们可以直接在 <code>cargo run</code> 后添加 <code>--</code>，并在其后跟上参数来传递：</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
</code></pre>
<p>如你所见，没有任何输出。这非常好，意味着我们的程序运行完成且没有错误！</p>
<aside class="exercise">
<p><strong>练习：</strong>
让这个程序打印出它的参数！</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grrs-的第一个实现"><a class="header" href="#grrs-的第一个实现"><em>grrs</em> 的第一个实现</a></h1>
<p>完成命令行参数章节后，我们获取了输入参数，现在我们可以开始编写实现工具了。
当前我们的 <code>main</code> 函数中仅有一行：</p>
<pre><code class="language-rust ignore">let args = Cli::from_args();
</code></pre>
<p>首先让我们打开指定的文件。</p>
<pre><code class="language-rust ignore">let content = std::fs::read_to_string(&amp;args.path)
    .expect(&quot;could not read file&quot;);
</code></pre>
<aside>
<p><strong>注:</strong>
看到 <a href="https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect"><code>.expect</code></a> 方法了吧？这是一个快捷功能，当无法读取到值时
（在这里是输入的文件）会立即退出程序。它还并不完美，在下节
<a href="tutorial/./errors_zh.html">更好地反馈错误</a> 中，我们将探究如何改进它。</p>
</aside>
<p>现在，让我们遍历所有行并打印出包含匹配字符串的每一行：</p>
<pre><code class="language-rust ignore">for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre>
<h2 id="wrapping-up-1"><a class="header" href="#wrapping-up-1">Wrapping up</a></h2>
<p>你的代码现在看起来应该如此：</p>
<pre><code class="language-rust ignore">#![allow(unused)]

use structopt::StructOpt;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(StructOpt)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    #[structopt(parse(from_os_str))]
    path: std::path::PathBuf,
}

fn main() {

let args = Cli::from_args();
let content = std::fs::read_to_string(&amp;args.path)
    .expect(&quot;could not read file&quot;);

for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}

}
</code></pre>
<p>来试试：<code>cargo run -- main src/main.rs</code> 应该能正常工作了！</p>
<aside class="exercise">
<p><strong>练习:</strong>
这并非最好的实现：它将整个文件读取到内存中了——无论文件有多大。
去寻找一种优化的方法吧！（使用 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html"><code>BufReader</code></a> 而非 <code>read_to_string()</code> 也许不错）</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更好地反馈错误"><a class="header" href="#更好地反馈错误">更好地反馈错误</a></h1>
<p>我们都知道，错误有时是无可避免的。与其它许多语言不同，
在使用 Rust 时很难不注意和而对这个现实：Rust 没有异常，
所有可能的错误状态通常都编码在函数的返回类型中。</p>
<h2 id="结果"><a class="header" href="#结果">结果</a></h2>
<p>像 <a href="https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html"><code>read_to_string</code></a> 这样的函数不会返回字符串。它返回的是一个 <a href="https://doc.rust-lang.org/1.39.0/std/result/index.html"><code>Result</code></a>，
里面可能是一个 <code>String</code> 或是其它错误类型（这里是 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>）。</p>
<p>那么如何得知是哪种类型呢？因为 <code>Result</code> 亦是 <code>enum</code> 类型，
可以使用 <code>match</code> 去检查里面是哪种变体：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
match result {
    Ok(content) =&gt; { println!(&quot;File content: {}&quot;, content); }
    Err(error) =&gt; { println!(&quot;Oh noes: {}&quot;, error); }
}
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>注：</strong>
若不清楚 enum 是什么或在 Rust 中如何使用它，可查看
<a href="https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html">enums</a>。</p>
</aside>
<h2 id="展开"><a class="header" href="#展开">展开</a></h2>
<p>现在，我们可以访问文件的内容，但在 <code>match</code> 代码块后无法对它做任何事情。
因此，我们需要以某种方式处理错误的情况。
难点在于，<code>match</code> 代码块的所有分支都应返回一个相同的类型。
好在这儿有个巧妙的技巧可以解决这个问题：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { panic!(&quot;Can't deal with {}, just exit here&quot;, error); }
};
println!(&quot;file content: {}&quot;, content);
<span class="boring">}
</span></code></pre></pre>
<p>我们可以在 match 代码块后使用 <code>content</code>。如果 <code>result</code> 是一个错误，
字符串就不存在。但好在，程序会在我们使用 <code>content</code> 之前就退出了。</p>
<p>这种做法看上去有些极端，却是十分实用的。如果你的程序需要读取一个文件，
且在文件不存在时无法执行任何操作，那么退出是十分合理、有效的选择。
在 <code>Result</code> 中还有一个快捷方法，叫 <code>unwrap</code>：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let content = std::fs::read_to_string(&quot;test.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2 id="无须-panic"><a class="header" href="#无须-panic">无须 panic</a></h2>
<p>当然，退出程序并非处理错误的唯一办法。除 <code>!panic</code> 之外，实现 <code>return</code> 也很简单：</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
</span>let result = std::fs::read_to_string(&quot;test.txt&quot;);
let _content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { return Err(error.into()); }
};
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>然而，这改变了我们函数的返回值类型。实际上，一直以来我们的示例都隐藏了一些东西：
函数的签名（或者说返回值类型）。在最后的含有 <code>return</code> 的示例中，它变得很重要了。
下面是_完整_的示例：</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = std::fs::read_to_string(&quot;test.txt&quot;);
    let content = match result {
        Ok(content) =&gt; { content },
        Err(error) =&gt; { return Err(error.into()); }
    };
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>我们的返回值类型是 <code>Result</code>！这也就是为什么我们可以在 match 的第二个分支里写
<code>return Err(error)</code>。看到最下面的 <code>Ok(())</code> 了么？它是函数的默认返回值，
意为“结果没问题，没有内容”。</p>
<aside>
<p><strong>注：</strong>
为什么不写成 <code>return Ok(())</code>？当然这样写也完全没问题。
在 Rust 中，任何代码块中的最后的表达式即为其返回值，因此习惯上省略了 <code>return</code>。</p>
</aside>
<h2 id="-标识"><a class="header" href="#-标识"><code>?</code> 标识</a></h2>
<p>正如调用 <code>.unwrap()</code> 相当于 <code>match</code> 中快捷设置错误分支中 <code>panic!</code>，
我们还有另一个快捷的调用 <code>?</code> 使得在 <code>match</code> 的错误分支中直接返回。</p>
<p>是的，就是这个问号。你可以在 <code>Result</code> 类型后加上这个运算符，
Rust 在内部会将之展开生成类似于我们刚写的 <code>match</code> 代码块。</p>
<p>来试试吧：</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let content = std::fs::read_to_string(&quot;test.txt&quot;)?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>很简洁是吧！</p>
<aside>
<p><strong>注：</strong>
这里还发生了一些事情，但我们不需要去理解就能使用它。
比如，在我们的 <code>main</code> 函数中，错误类型是 <code>Box&lt;dyn std::error::Error&gt;</code>。
但我们在 <code>read_to_string</code> 中返回的却是 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>。
它能正常工作是因为 <code>?</code> 将代码扩展为 <em>converts</em> 错误类型。</p>
<p><code>Box&lt;dyn std::error::Error&gt;</code> 同样是个很有意思的类型。
它是一个包含_任意_实现了标准 <a href="https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html"><code>Error</code></a> 特征类型的 <code>Box</code>，
所以我们可以在所有返回 <code>Result</code> 的一般函数里使用 <code>?</code>。</p>
</aside>
<h2 id="providing-context"><a class="header" href="#providing-context">Providing Context</a></h2>
<p>在 <code>main</code> 函数中使用 <code>?</code> 来获取错误，可以正常工作，但它有一些不足。
比如：若使用 <code>std::fs::read_to_string(&quot;test.txt&quot;)?</code> 时，<code>test.txt</code> 文件不存在，
你将获得以下错误信息：</p>
<pre><code class="language-text">Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre>
<p>在这里你的代码里没有包含文件名，这会使得确认是哪个文件 <code>NotFound</code> 变得很麻烦。
但我们有许多种办法可以改进它。</p>
<p>比如，我们可以创建一个自己的错误类型，然后使用它去生成自定义的错误信息：</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct CustomError(String);

fn main() -&gt; Result&lt;(), CustomError&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .map_err(|err| CustomError(format!(&quot;Error reading `{}`: {}&quot;, path, err)))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre>
<p>现在，运行它将得到我们自定义的错误信息：</p>
<pre><code class="language-text">Error: CustomError(&quot;Error reading `test.txt`: No such file or directory (os error 2)&quot;)
</code></pre>
<p>尽管不是很完美，但我们稍后可以很轻松地为我们的类型调试输出。</p>
<p>这种模式很觉，但它有一个问题：我们并没有保存下原始错误，而只存储了它呈现的字符串。
一个名为 <a href="https://docs.rs/anyhow"><code>anyhow</code></a> 的常用库可巧妙的解决这个问题：类似于 <code>CustomError</code> 类型，
它的 <a href="https://docs.rs/anyhow/1.0/anyhow/trait.Context.html"><code>Context</code></a> 特征可以用来添加描述信息。此外，它还能存储下原始错误，
所以我们得到了一个指出根本原因的错误信息链。</p>
<p>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 字段添加上 <code>anyhow = &quot;1.0&quot;</code>。</p>
<p>一个完整的示例如下：</p>
<pre><code class="language-rust ignore">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .with_context(|| format!(&quot;could not read file `{}`&quot;, path))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre>
<p>它将打印出一个错误：</p>
<pre><code class="language-text">Error: could not read file `test.txt`

Caused by:
    No such file or directory (os error 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输出"><a class="header" href="#输出">输出</a></h1>
<h2 id="打印-hello-world"><a class="header" href="#打印-hello-world">打印 “Hello World”</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>很简单是吧，让我们进入下一个话题。</p>
<h2 id="使用-println"><a class="header" href="#使用-println">使用 println</a></h2>
<p>使用 <code>println!</code> 宏你几乎可以打印出所有你喜欢的东西。这个宏有一些很棒的功能，
也有一些特殊的语法。它需要你写一个字符串作为第一个参数，其中包括占位符，
这些占位符将由后面的参数的值作为参数来填充。</p>
<p>比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!(&quot;My lucky number is {}.&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>将打印</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>上面字符串中的花括号（’{}’）就是占位符中的一种。这是默认的占位符类型，
它尝试以人类可读的方式打印出给定的参数的值。对于数字和字符串，这很好用，
但并不是所有的类型都可行。这就是为什么还有一个 “debug representation”，
你可以使用这个占位符来调用它 <code>{:?}</code>。</p>
<p>比如，</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!(&quot;The list is: {:?}&quot;, xs);
<span class="boring">}
</span></code></pre></pre>
<p>会打印</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>如果你想在调试和日志中打印自己构建的类型，大部分情况下你可以在类型定义上添加
<code>#[derive(Debug)]</code> 属性。</p>
<aside>
<p><strong>注：</strong>
“用户友好型”打印是通过 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html"><code>Display</code></a> 特征实现的，而调试输出（适用于开发者）
是使用 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html"><code>Debug</code></a> 特征。你可以在 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/index.html"><code>std::fmt</code> 模块文档</a>
查看更多关于使用 <code>println!</code> 的语法信息。</p>
</aside>
<h2 id="打印错误"><a class="header" href="#打印错误">打印错误</a></h2>
<p>打印错误应通过 <code>stderr</code> 完成，
以便用户和其它工具更方便的地将输出通过管道传输到文件或更多的工具中。</p>
<aside>
<p><strong>注：</strong>
在大部分操作系统中，一个程序可以将输出写到两个流中，<code>stdout</code> 和 <code>stderr</code>。
<code>stdout</code> 用于程序的实际输出，而 <code>stderr</code> 可将错误或其它信息与 <code>stdout</code> 分开。
这样，正确输出可以存储到文件或管道传输到其它程序中，同时将错误展示给用户。</p>
</aside>
<p>在 Rust 中，使用 <code>println!</code> 和 <code>eprintln!</code>，前者对应 <code>stdout</code> 而后者 <code>stderr</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;This is information&quot;);
eprintln!(&quot;This is an error! :(&quot;);
<span class="boring">}
</span></code></pre></pre>
<aside>
<p><strong>当心</strong>: 打印 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">escape codes</a> 可能很危险，会导致用户的终端变成奇异的状态。
在手动打印时请务必小心使用！</p>
<p>在你处理原始转义码时，最好使用 <code>ansi_term</code> 这样的 crate，
以便你（和你程序的用户）更安心。</p>
</aside>
<h2 id="关于打印性能的说明"><a class="header" href="#关于打印性能的说明">关于打印性能的说明</a></h2>
<p>打印到终端时出奇的慢！如果你在循环中调用 <code>println!</code> 之类的东西，
它很容易成为其它运行速度快的程序的瓶颈。你可以做两件事来为它提提速。</p>
<p>首先，你需要尽量减少实际“刷新”到终端的写入次数。_每次_调用 <code>println!</code>时，
它都会告诉系统刷新到终端，因为打印每个新行是很常见的。如果你不需要如此，
你可以使用 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a> 来包装一下 <code>stdout</code> 的句柄，它的默认缓存为 8 kB。
（当你想立即打印时，在 <code>BufWriter</code> 上调用 <code>.flush()</code> 即可。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>其次，为 <code>stdout</code>（或 <code>stderr</code>）申请一把锁并使用 <code>writeln!</code> 来直接打印很有用。
它会阻止系统不停地锁死和解锁 <code>stdout</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = stdout.lock(); // acquire a lock on it
writeln!(handle, &quot;foo: {}&quot;, 42); // add `?` if you care about errors here
<span class="boring">}
</span></code></pre></pre>
<p>你也可以结合使用这两种方式。</p>
<h2 id="显示进度条"><a class="header" href="#显示进度条">显示进度条</a></h2>
<p>一些 CLI 程序的运行时间很长，会花费几分钟甚至数小时。
如果你在编写这种程序，你可能希望向用户展示，其正在正常工作中。
因此，你需要打印出有用的状态更新信息，最好是使用易于使用的方式打印。</p>
<p>你可以使用 <a href="https://crates.io/crates/indicatif">indicatif</a> crate 来为你的程序添加进度条，这是一个简单的例子：</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!(&quot;[+] finished #{}&quot;, i));
        pb.inc(1);
    }
    pb.finish_with_message(&quot;done&quot;);
}
</code></pre>
<p>细节可查看 <a href="https://docs.rs/indicatif">indicatif 文档</a> 和 <a href="https://github.com/mitsuhiko/indicatif/tree/master/examples">示例</a>。</p>
<h2 id="日志"><a class="header" href="#日志">日志</a></h2>
<p>为了更方便了解到我们的程序做了什么，我们需要给它添加上一些日志语句，这很简单。
但在长时间后，例半年后再运行这个程序时，日志就变得非常有用了。在某些方面来说，
日志的使用方法同 <code>println</code> 类似，只是它可以指定消息的重要性（级别）。
通常可以使用的级别包括 <em>error</em>, <em>warn</em>, <em>info</em>, <em>debug</em>, and <em>trace</em>
（<em>error</em> 优先级最高，<em>trace</em> 最低）。</p>
<p>只需这两样东西，你就可以给你的程序添加简单的日志功能：
<a href="https://crates.io/crates/log">Log</a> 箱（其中包含以日志级别命名的宏）和一个 <em>adapter</em>，
它会将日志写到有用的地方。日志适配器的使用是十分灵活的：
例如，你可以不仅将日志写入终端，同时也可写入 <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> 或其它日志服务器。</p>
<p>因为我们现在最关心的是写一个 CLI 程序，所以选一个易于使用的适配器 <a href="https://crates.io/crates/env_logger">env_logger</a>。
它之所以叫 “env” 日志记录器，因为你可以使用环境变量来指定，
程序中哪部分日志需要记录及记录哪种级别日志。
它会在你的日志信息前加上时间戳及所在模块信息。
由于库也可以使用 <code>log</code>，你也可以轻松地配置它们的日志输出。</p>
<p>这里有个简单的例子：</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!(&quot;starting up&quot;);
    warn!(&quot;oops, nothing implemented!&quot;);
}
</code></pre>
<p>如果你有 <code>src/bin/output-log.rs</code> 这个文件，在 Linux 或 MacOS 上，你可以运行：</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows PowerShell，运行：</p>
<pre><code class="language-console">$ $env:RUST_LOG=&quot;info&quot;
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows CMD，运行：</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code> 是设置 log 的环境变量名。
<code>env_logger</code> 还包含一个构建器，因此你可以以编程的方式调整这些设置，
例如，还默认显示 <em>info</em> 级别的日志。</p>
<p>还有很多可选的日志适配器，以及日志库或其扩展。
如果你确定你的应用将生成很多日志，请务必查看它们，以便解决发现的问题。</p>
<aside>
<p><strong>小技巧：</strong>
经验表明，即使是稍有用的 CLI 程序也可能在未来几年的时间里被使用。
（特别是当它们是临时解决方案时）如果你的程序不能正常工作了，
有人（可能是未来的你）需要去查明其原因，
若能通过添加 <code>--verbose</code> 参数来获取更多额外的日志输出会大大减少调试时间。
<a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> 箱提供了使用 <code>structop</code>
将 <code>--verbose</code> 添加到项目中的便捷的方法。</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<p>在数十年的软件开发中，人们发现了一个真理：未经测试的软件很难正常工作。
（许多人也会说，经过测试的软件也可能不工作，但我们都是乐观主义者，不是么）
所以，为了确保你的程序可如你预期的那样工作，最好先对其进行测试。</p>
<p>一种简单的方式是在 <code>README</code> 文件中写明你的软件将如何工作。
当你准备好进行一次新的发布时，再过一遍 <code>README</code> 的功能并确定其仍能正常工作。
你还可以写入你的程序如何应对错误的输入，使得这个测试变得更加严格。</p>
<p>另一个绝妙的主意是：在写代码前先写 <code>README</code>。</p>
<aside>
<p><strong>注：</strong>
如果你没听过 <a href="https://zh.wikipedia.org/wiki/Test-driven_development">测试驱动开发</a> (TDD) 那么你最好去看一看它。</p>
</aside>
<h2 id="自动化测试"><a class="header" href="#自动化测试">自动化测试</a></h2>
<p>现在一切都妥了，但如果手动去完成测试，会耗费大量的时间。
现在，人们更喜欢让计算机来协助完成这些工作，下面我们来谈谈自动化测试。</p>
<p>Rust 有内建的测试框架，让我们试着写出一个测试吧：</p>
<pre><code class="language-rust ignore">#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
</code></pre>
<p>你可以把这段代码放在几乎任何文件，<code>cargo test</code> 将运行它。
这里的关键是 <code>#[test]</code> 属性。构建系统会寻找这类函数，并当作测试去运行它们，
确认他们不会出错（panic）。</p>
<aside class="exercise">
<p><strong>练习：</strong>
让这个测试能正常工作。</p>
<p>完成后，测试的输出应该是这样的：</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>现在我们已经了解了如何去编写测试项，那么下一个问题就是要测试什么？
如你所见，为函数写断言非常简单。但 CLI 程序通常不止一个功能函数！
更麻烦的是，它通常要处理用户的输入、读取文件并写入输出。</p>
<h2 id="编写可测试的代码"><a class="header" href="#编写可测试的代码">编写可测试的代码</a></h2>
<p>测试功能有两种互补的方法：
测试构建成完整程序的功能小单元，叫作“单元测试”。
还有就是从外部测试最终的程序，称为“黑盒测试”或“集成测试”。
让我们先从单元测试开始。</p>
<p>为了弄清楚我们要测试什么，让我们先看看我们程序的功能。
<code>grrs</code> 应该打印出，文件中包含符合匹配字符串的行。
所以，让我们给<strong>匹配</strong>功能写一个单元测试：
我们希望确保我们最重要的逻辑部分能正常工作，
并且以一种不依赖于任何需要设置代码、变量的方式实现（比如，处理 CLI 参数）。</p>
<p>回到我们的 <code>grrs</code> 的<a href="tutorial/impl-draft_zh.html">第一个实现</a>，
当时我们在 <code>main</code> 函数中添加了如下代码块：</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre>
<p>遗憾的是，这样的代码很难测试。
首先，因为它在 <code>main</code> 函数中，所以我们不能简单的直接调用它。
而把这段代码移动到一个函数中，就可以很简单地解决这个问题了：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们可以在测试中调用这个函数了，让我们来看一下它的输出是什么：</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;);
    assert_eq!( // uhhhh
</code></pre>
<p>或者，我们还不能……现在，<code>find_matches</code> 会直接将输出打印到 <code>stdout</code>，比如在终端。
我们不能简单地在测试中捕获它的输出！
这是在实现功能后再编写测试时经常遇到的问题：
我们编写了一个牢固地集成在它所使用的上下文中的函数。</p>
<aside class="note">
<p><strong>注：</strong>
这在编写一个小的 CLI 程序时问题不大。没必要去测试每个功能！
但重要的是要想清楚，哪些代码是需要去编写单元测试的。
虽然下面我们可以轻易的将这个函数修改为可测试的，但事情并非总是如此美好。</p>
</aside>
<p>那么，我们怎样才能让这个函数变得可测呢？我们得能获取它的输出。
Rust 的标准库有一些简单的抽象来处理 I/O，在这里我们将使用 <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>。
这是一个 <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a>，
它可以抽象我们可以写入的事物，包括字符串和标准输出。</p>
<p>如果你是第一次在 Rust 中看到 “trait” 这个词，也没关系。
特性（trait）是 Rust 最强大的特性之一。
你可以把它看成 Java 中的接口，或 Haskell 的 type classes（看你了解哪个）。
它允许你抽象可由不同类型共享的行为。
使用 trait 的代码可以以非常通用和灵活的方式来实现功能，
但这也意味着它可能难以阅读。
但请不要被它吓到：即使是 Rust 中的老手也不一定能马上理解通用代码的作用。
在这种情况下，考虑具体用途会有所帮助。
比如，现在，我们抽象的行为是“写入”。实现了（“impl”）了它的类型有：
终端的标准输出、文件、内存中的缓存或 TCP 网络连接。
（在<a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code> 文档</a> 中下翻可查看实现此 trait 的列表）</p>
<p>有了这些知识，让我们修改函数以便接受第三个参数。它应该是一个实现了 <code>Write</code>
的类型。这样，我们就可以在测试中提供一个简单的字符串并对其进行断言。
这是我们的 <code>find_matches</code> 的新版本：</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, &quot;{}&quot;, line);
        }
    }
}
</code></pre>
<p>第三个参数是 <code>mut writer</code>，即一个名为 <code>writer</code> 的可变变量。
它的类型是 <code>impl std::io::Write</code>，你可理解为“实现了 <code>Write</code> trait 的任意类型”。
还要注意，我们使用 <code>writeln!(writer, …)</code> 替换了之前的 <code>println!(…)</code>。
<code>println!</code> 的行为类似于 <code>writeln!</code>，只不过它总是写入到标准输出里。</p>
<p>现在我们可以测试它的输出了：</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;, &amp;mut result);
    assert_eq!(result, b&quot;lorem ipsum\n&quot;);
}
</code></pre>
<p>现在我们必须修改 <code>main</code> 函数中对 <code>find_matches</code> 的调用，给它加
<a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a> 作为第三个参数。
下面是修改完成之后，使用新版 <code>find_matches</code> 的 <code>mian</code> 函数：</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::from_args();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!(&quot;could not read file `{}`&quot;, args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}
</code></pre>
<aside class="note">
<p><strong>注：</strong>
由于 <code>stdout</code> 接收的是字节（而不是字符串）,
所以我们使用 <code>std::io::Write</code> 而不是 <code>std::fmt::Write</code>。
因此，我们在测试中传入了一个空的 vector 作为 “writer”
（它会被判断为 <code>Vec&lt;u8&gt;</code>），在 <code>assert_eq</code> 中我们使用 <code>b&quot;foo&quot;</code>。
（<code>b</code> 使得它被当作 <em>byte 字节</em>，即其类型为 <code>&amp;[u8]</code> 而非 <code>&amp;str</code>。</p>
</aside>
<aside class="note">
<p><strong>注：</strong>
我们也可以让这个函数（<code>find_matches</code>）返回一个 <code>String</code>，
但这样就改变了它的行为。即它不会直接将结果写入终端，
而是将所有的匹配行收集为一个字符串，并在最后返回一个结果。</p>
</aside>
<aside class="exercise">
<p><strong>练习：</strong>
<a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a> 返回值是 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a>，因为写入可能会失败，
例如缓存被用尽又无法申请新空间时。
请在 <code>find_matches</code> 添加上错误处理。</p>
</aside>
<p>我们刚刚学习了如何使一段代码变得易于测试。我们做了：</p>
<ol>
<li>找到程序中的一段核心代码，</li>
<li>将它封装到一个独立的函数中，</li>
<li>让它的使用方法变得更为灵活。</li>
</ol>
<p>尽管我们的目标仅仅是让它具有可测试性，
但我们最终得到了一段符合 Rust 语言风格且可被复用的代码，这非常棒！</p>
<h2 id="将代码拆分为库和二进制"><a class="header" href="#将代码拆分为库和二进制">将代码拆分为库和二进制</a></h2>
<p>这里我们还需要做一些事情。到目前为止我们将所有的代码写到了 <code>src/main.rs</code> 里。
这意味着我们的项目只会编译成一个单独的二进制程序。
但我们也可以将我们的代码作为库提供，像这样：</p>
<ol>
<li>将 <code>find_matches</code> 函数放到新的 <code>src/lib.rs</code> 文件中。</li>
<li>在函数名前（<code>fn</code>）添加上 <code>pub</code> 标记（现在函数为 <code>pub fn find_matches</code>）
以便这个库的使用者可以访问这个函数。</li>
<li>将 <code>src/main.rs</code> 中的 <code>find_matches</code> 函数移除。</li>
<li>在 <code>fn main</code> 中使用 <code>grrs::find_matches</code> 去调用我们在库中的 <code>find_matches</code>
函数。</li>
</ol>
<p>Rust 处理项目的方式非常灵活，尽早地考虑清楚哪些功能要放到库中是个好主意。
例如，你可以考虑先为用于特定程序的逻辑编写一个库，然后像调用任意其它库一样，
在你的 CLI 程序中使用它。又或者，若你的项目会生成多个二进制程序，
你可以将其通用的功能放到库里，提高代码的复用性。</p>
<aside class="note">
<p><strong>注：</strong>
如果将所有的代码都放到 <code>src/main.rs</code> 里，这会让我们的代码变得难以阅读。
查看 <a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">module system</a> 可以帮助你去构建、组织你的代码结构。</p>
</aside>
<h2 id="通过运行-cli-程序来测试它们"><a class="header" href="#通过运行-cli-程序来测试它们">通过运行 CLI 程序来测试它们</a></h2>
<p>到目前为止，我们已经测试了我们程序中的_业务逻辑_，即 <code>find_matches</code> 函数。
这是非常有价值的，并且是迈向实现经过良好测试的代码的第一步。
（通常，这类测试被称为“单元测试”）</p>
<p>但还有许多代码是我们没有测试到的，因为：
我们写的一切都是为了与外界打交道！
想像一下，在你写 <code>main</code> 函数时，不小心留下了一段硬编码的路径字符串，
软件运行时会使用它而非用户提供的参数！
我们也需要编写这类的测试！（这个级别的测试一般被称为“集成测试”或“系统测试”）</p>
<p>从本质上讲，我们仍要编写函数并使用 <code>#[test]</code> 注释它们。
现在的问题是我们要在这些函数中做什么？
例如，我们想像运行一个普通程序一样使用我们项目的主程序。
我们还要将这些测试放入到一个全新的路径下：<code>tests/cli.rs</code>。</p>
<aside>
<p><strong>注：</strong>
依约定，<code>cargo</code> 会在 <code>tests/</code> 目录中查找集成测试。
同样，它会在 <code>benches/</code> 目录寻找 benchmarks，在 <code>examples/</code> 中寻找示例。
这些约定也扩展到你的主要源代码：
库有一个 <code>src/libs.rs</code> 文件，主程序是 <code>src/main.rs</code>，
如果这里有多个二进制程序，<code>cargo</code> 期望它们放在 <code>src/bin/&lt;name&gt;.rs</code> 中。
遵循这些约定可以让你的代码对于习惯阅读 Rust 代码的人更为友好。</p>
</aside>
<p>回想一下，<code>grrs</code> 是一个在文件中搜索字符串的小工具。
我们已经测试过了查找匹配项功能。让我们再想想还能测试哪些功能。</p>
<p>这里我想到了一些。</p>
<ul>
<li>如果文件不存在会怎样？</li>
<li>当没有搜索到匹配项时返回什么？</li>
<li>当我们少写一个（或都没写）参数时，我们的程序会以错误状态退出？</li>
</ul>
<p>这些都是有效的测试用例。
此外，我们还应该有一个成功的测试用例，即程序正常运行且找到至少一个匹配并打印。</p>
<p>为了让这类的测试更容易，我们将使用到 <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> 箱。
它提供了许多简洁的帮助程序，可以让我们运行我们的主程序并查看它的行为。
此外，我们还将添加 <a href="https://docs.rs/predicates"><code>predicates</code></a> 箱，
来帮助我们为 <code>assert_cmd</code> 的测试项编写断言（且具有很棒的错误消息）。
我们不会将这些依赖放到程序的主依赖中，
而是放到 <code>Cargo.toml</code> 的 <code>dev dependencies</code> 部分。
它们只会在开发时被使用到，而使用时则不会。</p>
<pre><code class="language-toml">
[dependencies]
structopt = &quot;0.3.22&quot;
</code></pre>
<p>设置完成后，让我们来创建我们的 <code>tests/cli.rs</code> 文件：</p>
<pre><code class="language-rust ignore">use assert_cmd::prelude::*; // Add methods on commands
use predicates::prelude::*; // Used for writing assertions
use std::process::Command; // Run programs

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;

    cmd.arg(&quot;foobar&quot;).arg(&quot;test/file/doesnt/exist&quot;);
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;No such file or directory&quot;));

    Ok(())
}
</code></pre>
<p>你可以像我们之前做测试时一样，通过运行 <code>cargo test</code> 来运行这个测试。
在第一次运行时可能会稍慢，因为我们要编译出项目的主程序，它在
<code>Command::cargo_bin(&quot;grrs&quot;)</code> 被调用。</p>
<h2 id="生成测试文件"><a class="header" href="#生成测试文件">生成测试文件</a></h2>
<p>我们刚编写的测试，只会在检查我们的程序的输入的文件参数不存在时输出的错误信息。
这是很重要的一个测试项，却不是最重要的：
让我们测试下，正确运行程序并打印出文件中匹配项的用例。</p>
<p>首先我们要有一个已知内容的文件，这样我们才能确认正确的输出是什么从而进行测试。
当然我们可以在项目中添加一个文件专门用来进行测试，或者也可以创建临时文件来测试。
在本教程中，我们选择后面一种做法。因为它相对更为灵活且也适用于其它测试用例；
比如，当你要测试去修改一个文件的时候。</p>
<p>为了生成这些临时文件，我们要使用到 <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a> 箱，
让我们把它添加到 <code>Cargo.toml</code> 的 <code>dev-dependencies</code> 中。</p>
<pre><code class="language-toml">anyhow = &quot;1.0&quot;
</code></pre>
<p>这就是新的测试用例，首先去创建一个临时文件（并获取到它的路径），
然后在里面填充一些内容，再去运行我们的程序来检查我们能否获得正确的输出。
当执行完这个代码后，<code>file</code> 将自动被删除。</p>
<pre><code class="language-rust ignore">use assert_fs::prelude::*;

#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new(&quot;sample.txt&quot;)?;
    file.write_str(&quot;A test\nActual content\nMore content\nAnother test&quot;)?;

    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;
    cmd.arg(&quot;test&quot;).arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains(&quot;test\nAnother test&quot;));

    Ok(())
}
</code></pre>
<aside class="exercise">
<p><strong>练习：</strong>
添加一个传入的匹配项为空字符串的集成测试，并按需去调整程序。</p>
</aside>
<h2 id="去测试什么"><a class="header" href="#去测试什么">去测试什么？</a></h2>
<h2 id="what-to-test"><a class="header" href="#what-to-test">What to test?</a></h2>
<p>虽然编写集成测试很有意思，但毕竟编写测试是要消耗时间的，
而且当你的程序行为有所变动时可能也需要去更新这些测试。
为了让我们花费的时间变得更有意义，我们应该问下自己，我们要测试什么？</p>
<p>一般来讲，为用户可以观察到的所有类型的行为编写集成测试是一个好主意。
这意味着你不需要去涵盖所有的边界情况：通常会有不同类型的示例，
再依赖于单元测试即可覆盖边界情况。</p>
<p>同样，尝试去测试你不能掌控的东西，并不是一个好主意。
测试 <code>--help</code> 的确切输出布局，会是一个坏主意，
相反，你可能只想检查其中某些元素是否存在。</p>
<p>根据程序的特性，你还可以尝试添加更多的测试技术。
比如，当你尝试去测试到所有的边界情况时，如果你提取了你程序的一部分，
并且发现你已经写了许多作为单元测试的示例情景，你可以看看 <a href="https://docs.rs/proptest"><code>proptest</code></a>。
如果你的程序会使用任意一个文件并解析它们，请试着写一个 <a href="https://rust-fuzz.github.io/book/introduction.html">fuzzer</a>
来查找边界条件下的 bugs。</p>
<aside>
<p><strong>注：</strong>
你可以在<a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">这里</a> 看到完整、可运行的源码。</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打包并发布一个-rust-工具"><a class="header" href="#打包并发布一个-rust-工具">打包并发布一个 Rust 工具</a></h1>
<p>如果你确信你的程序已经准备好提供给其它人使用了，那么是时候打包并发布它了！</p>
<p>我们可以有许多种办法，现在我们从“最快设置”到“对用户最方便”看其中的三种。</p>
<h2 id="最快的方法cargo-publish"><a class="header" href="#最快的方法cargo-publish">最快的方法：<code>cargo publish</code></a></h2>
<p>发布你的程序最简单的办法就是使用 cargo。
你还记得我们怎么往我们的项目中添加依赖么？
cargo 从默认的 “crate 仓库”<a href="https://crates.io/">crates.io</a> 下载它们。
使用 <code>cargo publish</code>，你可以在 <a href="https://crates.io/">crates.io</a> 上发布你的 crate。
这适用于包括二进制程序在内的所有 crates。</p>
<p>如果你已经在 <a href="https://crates.io/">crates.io</a> 上创建了一个账号，
那么在上面发布一个 crate 是非常简单的。
目前，它是通过 GitHub 来认证的，所以你需要一个 GitHub 账号,
并在 <a href="https://crates.io/">crates.io</a> 上登录。然后，你需要在你本地的机器上登录（终端登录）。
然后，<a href="https://crates.io/">crates.io</a> 的账号设置页面，生成一个新的 token，
在你的本地终端运行 <code>cargo login &lt;your-new-token&gt;</code>。
每台机器上只需运行一次即可一直使用。
有兴趣可以去看 cargo 的 <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html">publishing guide</a> </p>
<p>现在你已经了解了 cargo 和 crates.io，可以去发布你的 crate 了。
在你急急忙忙地想着发布一个新的（或更新版本）crate 前，
你最好打开 <code>Cargo.toml</code> 并检查是否提供了必要的元数据。
你可以在 <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html">cargo’s manifest format</a> 的文档中找到所有需要设置的字段，
下面展示了其中的常见条件：</p>
<pre><code class="language-toml">[package]
name = &quot;grrs&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;your@email.com&gt;&quot;]
license = &quot;MIT OR Apache-2.0&quot;
description = &quot;A tool to search files&quot;
readme = &quot;README.md&quot;
homepage = &quot;https://github.com/you/grrs&quot;
repository = &quot;https://github.com/you/grrs&quot;
keywords = [&quot;cli&quot;, &quot;search&quot;, &quot;demo&quot;]
categories = [&quot;command-line-utilities&quot;]
</code></pre>
<aside class="note">
<p><strong>注：</strong>
这个示例包括了必须的 license 字段，它选择了 Rust 项目中常见的许可证，
编译器本身也是使用的这个 license。
它还引用了 <code>README.md</code> 文件。
它应该包括一个对你的项目的简单描述信息，这个信息不仅会显示在 crates.io
上你的 crate 页面中，还在会 GitHub 仓库页面显示。</p>
</aside>
<h3 id="如何从-cratesio-上安装程序"><a class="header" href="#如何从-cratesio-上安装程序">如何从 crates.io 上安装程序</a></h3>
<p>我们刚刚学习了如何在 crates.io 上发布一个 crate，那么又如何去安装它呢？</p>
<p>我们同样可以使用 cargo 命令，运行 <code>cargo install &lt;crate-name&gt;</code>。
它默认会下载这个 crate，编译其中所有的二进制程序（使用 release 模式，
所以可能会稍慢）并将程序拷贝到 <code>~/.cargo/bin</code> 目录。
（需确保你的 PATH 中有这个路径，才可正常使用安装的命令）</p>
<p>我们还可以直接在源码仓库下安装程序，使用这种文件可以指定安装哪些二进制程序，
及程序安装到什么位置。详情可查看 <code>cargo install --help</code>。</p>
<h3 id="什么时候使用它"><a class="header" href="#什么时候使用它">什么时候使用它</a></h3>
<p>使用 <code>cargo install</code> 可以很方便的安装一个 crate 程序。
但你需要了解到它的几个不足之处：
因为它总是会从头开始编译你的源码，所以使用你的工具的用户，
在他们的机器上需要安装上 Rust，Cargo 及其它所需的依赖。
而且编译一个大型的 Rust 代码库也需要较长的时间。</p>
<p>最好使用它来分发面向其它 Rust 开发者的工具。
比如，许多 cargo 的子命令，
像 <code>cargo-tree</code> 或 <code>cargo-outdated</code> 可以使用这种方法来安装。</p>
<h2 id="发布二进制程序"><a class="header" href="#发布二进制程序">发布二进制程序</a></h2>
<p>Rust 会默认编译出使用静态链接的机器代码。
当你运行 <code>cargo build</code>时，若你的项目中有包含一个叫 <code>grrs</code> 的二进制 target，
你将得到一个叫 <code>grrs</code> 的二进制文件。
来试试吧：使用 <code>cargo build</code>，二进制文件在 <code>target/debug/grrs</code>，
若使用 <code>cargo build --release</code> 则生成的文件在 <code>target/release/grrs</code>。
除非你使用的 crates 中明确地说明了需要在目标系统上安装外部依赖库
（如需要使用系统提供的 OpenSSL），否则这个二进制文件只会依赖于通用系统库。
这意味着，将此二进制程序拷贝到任何相同的操作系统上，它都能完美地运行！</p>
<p>这已经很强大了！它解决了我们刚刚提到的，关于 <code>cargo isntall</code> 的两个不足：
它不需要用户的机器上安装 Rust，也不需要再去编译而可直接运行。</p>
<p>所以，<code>cargo build</code> _已经_为我们编译出了二进制程序。现在唯一的问题是，
还不能保证其可在所有的平台上都可用。如果你在 Windows 上运行 <code>cargo build</code>，
你并不会得到一个可在 Mac 上运行程序。
那么有没有办法为所有的常见平台自动生成这些二进制程序呢？</p>
<h3 id="使用-ci-构建二进制版本"><a class="header" href="#使用-ci-构建二进制版本">使用 CI 构建二进制版本</a></h3>
<p>如果你的工具已经开源且托管在 GitHub 上，可以非常容易地设置一个免费的 CI
（持续集成）—— <a href="https://travis-ci.com/">Travis CI</a>。（或其它平台上使用其它的服务，Travis 是最受欢迎的）
在你每次 push 新代码到你的仓库时，它会在一个虚拟机上运行设置命令。
至于是执行什么命令，或使用哪种虚拟机，这都是可以配置的。
比如，在一个安装了 Rust 和常用构建工具的机器上，执行 <code>cargo test</code> 是一个好主意。
如果这个命令失败了，你就知道最近的提交的代码是有问题的。</p>
<p>我们还可以使用它还构建二进制程序并上传到 GitHub 上！
那么，如果我们使用 <code>cargo build --release</code> 生成并将程序上传到某个地方，
就一切 OK 了么？也不尽然，我们需要确保我们的程序适用于尽可能多的系统。
比如，在 Linux 上我们可以不为当前系统编译，而是针对 <code>x86_64-unknown-linux-musl</code>
编译，从而使程序不依赖于默认的系统库。
在 macOS 上，我们可以设置 <code>MACOSX_DEPLOYMENT_TARGET</code> 为 <code>10.7</code>，
使得程序只会依赖于 10.7 及其之后版本上存在的系统功能。</p>
<p>你可以在<a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">这儿</a>看到使用此方法在 Linux 和 macOS 上编译的例子，
若使用 Windows，请看<a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">这个</a>（使用 AppVeyor）。</p>
<p>另一种方法是使用包含我们编译程序所需要到的所有工具的 pre-built (Docker) 镜像。
这也使我们能够轻松地编译适配于更多不同的平台。
在<a href="https://github.com/japaric/trust">trust</a> 项目中包含可以在你的项目中使用的脚本及其如何设置使用的说明。
它还支持使用 AppVeyor 的 Windows 系统。</p>
<p>如果你更愿意在本地设置，并在本机上生成要发布的文件，你也可以看看 trust。
它在里面使用了 <a href="https://github.com/rust-embedded/cross">cross</a>，cross 的工作原理类似于 cargo，
它会将命令转发到 Docker 容器中的 cargo 进程。
此镜像的定义相关可在其仓库查看 <a href="https://github.com/rust-embedded/cross">cross’ repository</a>。</p>
<h3 id="如何安装这些二进制程序"><a class="header" href="#如何安装这些二进制程序">如何安装这些二进制程序</a></h3>
<p>你的发布页面也许是像<a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">这样</a>的，
用户可以在这个页面下载我们刚生成的文件。
我们刚刚生成的发布文件没什么特别的：它们只是一个包括我们的二进制程序的压缩包！
这意味着你的工具的用户可以从浏览器上下载、解压，并将程序拷贝到任何地方。</p>
<p>这需要用户有手动安装程序的经验，所以你最好在你的 README 文件中加上安装方法说明。</p>
<aside class="note">
<p><strong>注：</strong>
如果你使用 <a href="https://github.com/japaric/trust">trust</a> 构建你的程序并在 GitHub releases 上发布，
你还可以告诉你的用户来运行
<code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code>
去安装，这也许会更简单些（相对于手动安装）。</p>
</aside>
<h3 id="什么时候使用它-1"><a class="header" href="#什么时候使用它-1">什么时候使用它</a></h3>
<p>一般来说使用 release 的二进制文件来安装是非常好的主意，它几乎没啥缺点。
虽然它没解决自动安装及更新的问题，
但可以在不安装 Rust 的情况下得到并使用相应的程序。</p>
<h3 id="除了二进制程序外还要打包什么"><a class="header" href="#除了二进制程序外还要打包什么">除了二进制程序外还要打包什么</a></h3>
<p>现在，当一个用户下载了我们的 release 构建程序，他会得到一个 <code>.tar.gz</code> 文件。
里面只包含了一些二进制文件。而在我们的示例项目中，只有一个可运行的 <code>grrs</code> 文件。
但在我们的仓库中，也许还有一些其它文件是用户想要的，
比如 README 中有程序的使用方法，license 文件有程序的许可信息。
我们可以非常容易地将这些已有的文件添加到 release 的压缩包中。</p>
<p>这里还有一些非常有意思且有用的文件，尤其是在命令行工具中：
除了 README 文件，我们再提供一个帮助手册怎么样，然后再添加一个支持 SHELL
自动补全功能的配置文件？你可以自己来手写这些，
或者使用 <em>clap</em>，
这个解析参数的库（structopt 就是基于它）提供了一个方法来帮我们生成这些文件。
详情可查看<a href="tutorial/../in-depth/docs_zh.html">深入了解</a>这一章。</p>
<h2 id="将你的软件放到软件仓库中"><a class="header" href="#将你的软件放到软件仓库中">将你的软件放到软件仓库中</a></h2>
<p>到目前为止，我们看到的两种方式都不是通常情况下你在计算机上安装软件的方式。
尤其在大多数操作系统上，会使用全局包管理器来进行命令行工具的安装。
这种包管理器对用户来说，优势非常明显：
他不需要去考虑如何安装你的软件，因为其安装方法和安装其它工具一样。
这些包管理器同样允许用户在软件有新版本时去更新它们。</p>
<p>不过，要支持不同的系统意味着你必须了解它们是如何工作的。
有一些是比较简单的
（比如，为 macOS 的 <code>brew</code> 添加一个 Formula 像<a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">这个</a>），
还有的需要你自己来发送补丁并将你的工具添加他们的软件仓库中。
这里有一些很有用的工具，像
<a href="https://crates.io/crates/cargo-rpm">cargo-rpm</a>、
<a href="https://crates.io/crates/cargo-deb">cargo-deb</a> 和
<a href="https://crates.io/crates/cargo-aur">cargo-aur</a>。
但它们是如何工作的及你要如何正确地为不同的系统打包你的工具不在本章的讨论范围中。。</p>
<p>现在，让我们看一下一个使用 Rust 编写，且在许多不同的包管理器中都存在的一个工具。</p>
<h3 id="一个示例ripgrep"><a class="header" href="#一个示例ripgrep">一个示例：ripgrep</a></h3>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> 是一个用 Rust 编写的，类似于 <code>grep</code>/<code>ack</code>/<code>ag</code> 的工具。
这是一个十分成功的项目，且打包分发支持了许多不同的操作系统：
请查看项目中 README 的<a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">安装</a> 部分。</p>
<p>注意，其中列出了几种安装它的办法：
首先它提供了一个指向 GitHub releases 页面的链接，在这儿你可以直接下载二进制程序；
然后，也列出了，如何使用不同的软件管理器来安装；
最后，你也可以使用 <code>cargo install</code> 来安装它！</p>
<p>不要只选择这里介绍的一种方法，而是先使用 <code>cargo install</code>，
然后再发布二进制 releases，最后再尝试使用系统包管理器来分发你的工具。
相信我，这会是一个好主意！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="再深入谈谈"><a class="header" href="#再深入谈谈">再深入谈谈</a></h1>
<p>一个小章节，涵盖了你在编写命令行程序时可能关心的更多细节问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信号处理"><a class="header" href="#信号处理">信号处理</a></h1>
<p>像命令行程序这种进程需要接受操作系统发出的信号并做出相应的反应。
最常见的就是 <kbd>Ctrl</kbd>+<kbd>C</kbd> 了，这是典型的终止进程的信号。
在 Rust 程序中处理信号，你需要考虑如何获取这些信号及如何做出反应。</p>
<aside>
<p><strong>注：</strong>
如果你的程序不需要优雅地关闭，那么默认的处理方式就很好（比如，立即退出，
并让系统清理资源如打开的文件的句柄）。
在这种情况下，就无须理会本章告诉你的操作了！</p>
<p>然后，对于一些需要做自我清理工作的程序，本章讲的东西就非常有用了!
比如，如果你的程序需要正确地关闭网络连接（向另一端发送结束语句），
移除临时文件或重置系统设置等，请继续往下看。</p>
</aside>
<h2 id="操作系统之间的差异"><a class="header" href="#操作系统之间的差异">操作系统之间的差异</a></h2>
<p>在 Unix 系统（比如 Linux、macOS 和 FreeBSD），进程可以接受 <a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html">signals</a>。
它可以以默认的方式（系统提供）来接收信号并以默认的方式处理它，
或者直接不理会这个信号。</p>
<p>Windows 没有信号。你可以使用 <a href="https://docs.microsoft.com/en-us/windows/console/console-control-handlers">Console Handlers</a> 来定义某事件发生后的回调。
还有 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling">structured exception handling</a>，它处理所有各种类型的系统异常，
如被零除，无效访问异常，堆栈溢出等。</p>
<h2 id="首先处理-ctrlc"><a class="header" href="#首先处理-ctrlc">首先：处理 Ctrl+C</a></h2>
<p><a href="https://crates.io/crates/ctrlc">ctrlc</a> 箱如其名：它允许你在用户按下 <kbd>Ctrl</kbd>+<kbd>C</kbd> 时，
去做出相应的反应，且它是跨平台的。其使用方法如下：</p>
<pre><code class="language-rust ignore">use std::{thread, time::Duration};

fn main() {
    ctrlc::set_handler(move || {
        println!(&quot;received Ctrl+C!&quot;);
    })
    .expect(&quot;Error setting Ctrl-C handler&quot;);

    // Following code does the actual work, and can be interrupted by pressing
    // Ctrl-C. As an example: Let's wait a few seconds.
    thread::sleep(Duration::from_secs(2));
}
</code></pre>
<p>当然，这没啥意义：它只是打印出了一段信息，而并没有退出程序。</p>
<p>在现实的程序中，在信号处理时去设置一个变量，
并在程序中各个位置去检查，会是一个好主意。
比如，你可以在信号处理程序中设置一个 <code>Arc&lt;AtomicBool&gt;</code>
（一个可在线程中共享的 boolean），并在一个无限循环中，或在等待线程时，
周期性地检查它的值，当它为真时退出程序。</p>
<h2 id="处理其它类型的信号"><a class="header" href="#处理其它类型的信号">处理其它类型的信号</a></h2>
<p><a href="https://crates.io/crates/ctrlc">ctrlc</a> 箱只会处理 <kbd>Ctrl</kbd>+<kbd>C</kbd>，或者在 Unix 系统中，称为
<code>SIGINT</code>（中断信号）。<a href="https://crates.io/crates/signal-hook">signal-hook</a> 可以去处理更多的 Unix 信号。
在 <a href="https://vorner.github.io/2018/06/28/signal-hook.html">this blog post</a> 中描述了它的设计原理，
且它是目前社区里支持最为广泛的库。</p>
<p>一个简单的示例：</p>
<pre><code class="language-rust ignore">use signal_hook::{consts::SIGINT, iterator::Signals};
use std::{error::Error, thread, time::Duration};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut signals = Signals::new(&amp;[SIGINT])?;

    thread::spawn(move || {
        for sig in signals.forever() {
            println!(&quot;Received signal {:?}&quot;, sig);
        }
    });

    // Following code does the actual work, and can be interrupted by pressing
    // Ctrl-C. As an example: Let's wait a few seconds.
    thread::sleep(Duration::from_secs(2));

    Ok(())
}
</code></pre>
<h2 id="使用通道channels"><a class="header" href="#使用通道channels">使用通道（channels)</a></h2>
<p>除了设置一个变量并在程序其它部分去检查它，你还可以使用通道：
创建一个通道，在信号处理器接收到信号后，向里面发送一个值。
在你的程序代码中，使用此通道和其他通道作为线程之间的同步点。
像这样使用 <a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a>：</p>
<pre><code class="language-rust ignore">use std::time::Duration;
use crossbeam_channel::{bounded, tick, Receiver, select};
use anyhow::Result;

fn ctrl_channel() -&gt; Result&lt;Receiver&lt;()&gt;, ctrlc::Error&gt; {
    let (sender, receiver) = bounded(100);
    ctrlc::set_handler(move || {
        let _ = sender.send(());
    })?;

    Ok(receiver)
}

fn main() -&gt; Result&lt;()&gt; {
    let ctrl_c_events = ctrl_channel()?;
    let ticks = tick(Duration::from_secs(1));

    loop {
        select! {
            recv(ticks) -&gt; _ =&gt; {
                println!(&quot;working!&quot;);
            }
            recv(ctrl_c_events) -&gt; _ =&gt; {
                println!();
                println!(&quot;Goodbye!&quot;);
                break;
            }
        }
    }

    Ok(())
}
</code></pre>
<h2 id="使用-futures-和-streams"><a class="header" href="#使用-futures-和-streams">使用 futures 和 streams</a></h2>
<p>如果你使用 <a href="https://tokio.rs/">tokio</a>，那你应该已经写了一个使用异步编程的事件驱动型的程序。
除了直接使用 crossbeam 的通道之外，
你还可以启用 signal-hook 的 <code>tokio-support</code> feture。
它允许你在 signal-hook 的 <code>Signals</code> 类上调用 <a href="https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async"><code>.into_async()</code></a>
来获得一个实现了 <code>futures::Stream</code> 的新类型。</p>
<h2 id="当处理-ctrlc-时又接收到新的-ctrlc-时怎么办"><a class="header" href="#当处理-ctrlc-时又接收到新的-ctrlc-时怎么办">当处理 Ctrl+C 时又接收到新的 Ctrl+C 时怎么办</a></h2>
<p>大部分用户会按下 <kbd>Ctrl</kbd>+<kbd>C</kbd>，
等待你的程序退出（也许需要几秒钟）或告诉他们接下来要怎么办。
如果没效果，他们会再次按下 <kbd>Ctrl</kbd>+<kbd>C</kbd>。
一般情况下，此时程序会立即退出！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用配置文件"><a class="header" href="#使用配置文件">使用配置文件</a></h1>
<p>处理配置可能会很麻烦，尤其是当你支持多个操作系统，
而这些操作系统有不同的固定或临时配置文件存放位置。</p>
<p>有许多种办法可以解决这个问题，一些的方式会更接近低层。
There are multiple solutions to this,
some being more low-level than others.</p>
<p>最容易使用的 crate 是 <a href="https://docs.rs/confy/0.3.1/confy/"><code>confy</code></a>。
它要求你提供程序的名称，并要求你通过 <code>struct</code> 来定义配置
（需实现 <code>Serialize</code> 和 <code>Deserialize</code>），剩下的事儿交给它就可以了！</p>
<pre><code class="language-rust ignore">#[derive(Debug, Serialize, Deserialize)]
struct MyConfig {
    name: String,
    comfy: bool,
    foo: i64,
}

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let cfg: MyConfig = confy::load(&quot;my_app&quot;)?;
    println!(&quot;{:#?}&quot;, cfg);
    Ok(())
}
</code></pre>
<p>在你放弃可配置性时，毫无疑问它是极其方便好用的。
所以在你需要简单的配置时，使用这个 crate 会非常合适。</p>
<h2 id="配置环境"><a class="header" href="#配置环境">配置环境</a></h2>
<aside class="todo">
<p><strong>TODO</strong></p>
<ol>
<li>Evaluate crates that exist</li>
<li>Cli-args + multiple configs + env variables</li>
<li>Can <a href="https://docs.rs/configure/0.1.1/configure/"><code>configure</code></a> do all this? Is there a nice wrapper around it?</li>
</ol>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="退出状态码"><a class="header" href="#退出状态码">退出状态码</a></h1>
<p>程序不总是能成功地运行。当发生错误时，你需要确保正确地发出必要的信息。
此外如 <a href="in-depth/human-communication.html">telling the user about errors</a> 中所说，
在大部分系统中，当一个进程退出，它会发出一个退出状态码
（在大部分平台上是一个 0 至 255 的数字）。
你应该为你的程序发出正确的退出码。
比如，当你的程序成功运行后，它应该生成 <code>0</code> 的退出码。</p>
<p>但当发生错误时，它会变得更复杂一些。
大多数情况下，许多工具在发生一般性错误时会以 <code>1</code> 为退出码。
目前，Rust 为 panicked 的进程设置了 <code>101</code> 的退出状态码。
除此之外，人们在他们的程序中做了许多事情。</p>
<p>所以，要如何去做呢？BSD 生态系统为其退出码做了一个通用的定义
（你可以在<a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">这里</a>找到它们）。
Rust 的 <a href="https://crates.io/crates/exitcode"><code>exitcode</code></a> 库也提供了一样的代码，且你可在你的程序中使用。
请参阅其 API 文档以了解其用法。</p>
<p>当你在你的 <code>Cargo.toml</code> 中添加 <code>exitcode</code> 依赖后，你可以这样使用：</p>
<pre><code class="language-rust ignore">fn main() {
    // ...actual work...
    match result {
        Ok(_) =&gt; {
            println!(&quot;Done!&quot;);
            std::process::exit(exitcode::OK);
        }
        Err(CustomError::CantReadConfig(e)) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::CONFIG);
        }
        Err(e) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::DATAERR);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与人交互"><a class="header" href="#与人交互">与人交互</a></h1>
<p>你需要先去阅读<a href="in-depth/../tutorial/output_zh.html">输出</a>这一章节。
它介绍了如何在终端中写入输入，而本节将谈谈写入哪些输出。</p>
<h2 id="当一切都正常时"><a class="header" href="#当一切都正常时">当一切都正常时</a></h2>
<p>即使一切正常，报告程序的进度也很有用。但要尽量提供简洁有用的信息。
不要在日志中使用过于专业的术语。
请记住，此时程序没有崩溃，所以用户没必要去查找错误。</p>
<p>最重要的是，要保证简洁，使用相同的前缀和语句结构以便日志更易于阅读。</p>
<p>要试着让你的程序的输出讲清楚它在做什么，及对用户有什么影响。
这可能涉及显示其步骤的时间线，甚至在长时间运行的程序中显示一个进度条和指示器。
用户在任何时候都不应该有程序在做一些他们无法理解的神秘的事情的感觉。</p>
<h2 id="当很难说清楚发生了什么时"><a class="header" href="#当很难说清楚发生了什么时">当很难说清楚发生了什么时</a></h2>
<p>在传达非名义状态时，保持一致很重要。
与无日志应用相比，不严格遵循日志记录级别且生成大量日志的程序，
其提供的信息量会相同，甚至于更少。</p>
<p>所以，定义与之相关的事件和消息的严重性很重要；然后为它们使用一致的日志级别。
使用这种方法使得用户可以使用 <code>--verbose</code>
或设置环境变量（如 <code>RUST_LOG</code>）来得到大量的 log 信息。</p>
<p>通常会使用到 <code>log</code> 箱来 <a href="https://docs.rs/log/0.4.4/log/enum.Level.html">defines</a> 这些 log 等级（按严重级别排列）：</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>将 <em>info</em> 设置为默认的日志级别来输出信息是个好主意。
（一些应用更倾向于更为安静的输出——默认只输出警告和错误信息）</p>
<p>此外，保持使用相同的前缀和日志语句格式，总会是最好的选择！
这样可以更方便地使用 <code>grep</code> 命令来筛选日志。
在一条日志消息中，需要提供足够的信息来方便进行日志筛选，但也不要太过详尽、冗长。</p>
<h3 id="日志句法示例"><a class="header" href="#日志句法示例">日志句法示例</a></h3>
<pre><code class="language-console">error: could not find `Cargo.toml` in `/home/you/project/`
</code></pre>
<pre><code class="language-console">=&gt; Downloading repository index
=&gt; Downloading packages...
</code></pre>
<p><a href="https://crates.io/crates/wasm-pack">wasm-pack</a> 中的日志：</p>
<pre><code class="language-console"> [1/7] Adding WASM target...
 [2/7] Compiling to WASM...
 [3/7] Creating a pkg directory...
 [4/7] Writing a package.json...
 &gt; [WARN]: Field `description` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `repository` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `license` is missing from Cargo.toml. It is not necessary, but recommended
 [5/7] Copying over your README...
 &gt; [WARN]: origin crate has no README
 [6/7] Installing WASM-bindgen...
 &gt; [INFO]: wasm-bindgen already installed
 [7/7] Running WASM-bindgen...
 Done in 1 second
</code></pre>
<h2 id="崩溃的时候"><a class="header" href="#崩溃的时候">崩溃的时候</a></h2>
<p>一个常被忽略的点是——程序在崩溃的时候也要输出一些东西。
在 Rust 中，崩溃通常是程序的 <code>panics</code>（“可控崩溃”不“操作系统直接杀死进程”不同）。
默认情况下，当 panic 发生时，“panic handler” 会在终端中打印一些有用信息。</p>
<p>比如，你使用 <code>cargo new --bin foo</code> 生成一个新的二进制项目，
并在 <code>fn main</code> 中添加一句 <code>panic!(&quot;Hello World&quot;)</code>，当你运行程序时：</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>这对于你，开发者来说，是有用的信息。（哈哈：你的程序在 <code>main.rs</code> 第二行崩溃了）
但对于那些没源码的人，它没什么价值，而且事实上，它只会让人感到更为困惑。
所以，添加一个更为面向终端用户的自定义 panic 处理器是一个好主意！</p>
<p><a href="https://crates.io/crates/human-panic">human-panic</a> 就是一个做这样的库。把它添加到你的 CLI 项目中，导入，
并在你的 <code>main</code> 函数的开头调用 <code>setup_panic!()</code> 宏：</p>
<pre><code class="language-rust ignore">use human_panic::setup_panic;

fn main() {
   setup_panic!();

   panic!(&quot;Hello world&quot;)
}
</code></pre>
<p>现在它将显示更为友好的信息，并告诉用户他们能做什么：</p>
<pre><code class="language-console">Well, this is embarrassing.

foo had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at &quot;/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml&quot;. Submit an issue or email with the subject of &quot;foo Crash Report&quot; and include the report as an attachment.

- Authors: Your Name &lt;your.name@example.com&gt;

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与机器交互"><a class="header" href="#与机器交互">与机器交互</a></h1>
<p>当你能够将命令行工具组合到一起时，它们的威力就会大放异彩！
这并不是一个新的点子，事实上，它来源的 <a href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6">Unix 哲学</a>：</p>
<blockquote>
<p>程序应该只关注一个目标，并尽可能把它做好。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。</p>
</blockquote>
<p>如果我们的程序能做到这些，那么我们的用户将会非常高兴的。
为了能做到这点，我们要保证我们的输出信息不止适用于人类阅读，
也要是对其它程序来说是可用的。现在让我们看看，如何做到这点。</p>
<aside>
<p><strong>注：</strong>
Make sure to read <a href="in-depth/../tutorial/output.html">the chapter on CLI output</a>
in the tutorial first.
It covers how to write output to the terminal.</p>
</aside>
<h2 id="whos-reading-this"><a class="header" href="#whos-reading-this">Who’s reading this?</a></h2>
<p>The first question to ask is:
Is our output for a human in front of a colorful terminal,
or for another program?
To answer this,
we can use a crate like <a href="https://crates.io/crates/atty">atty</a>:</p>
<pre><code class="language-rust ignore">use atty::Stream;

if atty::is(Stream::Stdout) {
    println!(&quot;I'm a terminal&quot;);
} else {
    println!(&quot;I'm not&quot;);
}
</code></pre>
<p>Depending on who will read our output,
we can then add extra information.
Humans tend to like colors,
for example,
if you run <code>ls</code> in a random Rust project,
you might see something like this:</p>
<pre><code class="language-console">$ ls
CODE_OF_CONDUCT.md   LICENSE-APACHE       examples
CONTRIBUTING.md      LICENSE-MIT          proptest-regressions
Cargo.lock           README.md            src
Cargo.toml           convey_derive        target
</code></pre>
<p>Because this style is made for humans,
in most configurations
it’ll even print some of the names (like <code>src</code>) in color
to show that they are directories.
If you instead pipe this to a file,
or a program like <code>cat</code>,
<code>ls</code> will adapt its output.
Instead of using columns that fit my terminal window
it will print every entry on its own line.
It will also not emit any colors.</p>
<pre><code class="language-console">$ ls | cat
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Cargo.lock
Cargo.toml
LICENSE-APACHE
LICENSE-MIT
README.md
convey_derive
examples
proptest-regressions
src
target
</code></pre>
<h2 id="easy-output-formats-for-machines"><a class="header" href="#easy-output-formats-for-machines">Easy output formats for machines</a></h2>
<p>Historically,
the only type of output command-line tools produced were strings.
This is usually fine for people in front of terminals,
who are able to read text
and reason about its meaning.
Other programs usually don’t have that ability, though:
The only way for them to understand the output of a tool
like <code>ls</code>
is if the author of the program included a parser
that happens to work for whatever <code>ls</code> outputs.</p>
<p>This often means
that output was limited to what is easy to parse.
Formats like TSV (tab-separated values),
where each record is on its own line,
and each line contains tab-separated content,
are very popular.
These simple formats based on lines of text
allow tools like <code>grep</code>
to be used on the output of tools like <code>ls</code>.
<code>| grep Cargo</code> doesn’t care if your lines are from <code>ls</code> or file,
it will just filter line by line.</p>
<p>The downside of this is that you can’t use
an easy <code>grep</code> invocation to filter all the directories that <code>ls</code> gave you.
For that, each directory item would need to carry additional data.</p>
<h2 id="json-output-for-machines"><a class="header" href="#json-output-for-machines">JSON output for machines</a></h2>
<p>Tab-separated values is a simple way
to output structured data
but it requires the other program to know which fields to expect
(and in which order)
and it’s difficult to output messages of different types.
For example,
let’s say our program wanted to message the consumer
that it is currently waiting for a download,
and afterwards output a message describing the data it got.
Those are very different kinds of messages
and trying to unify them in a TSV output
would require us to invent a way to differentiate them.
Same when we wanted to print a message that contains two lists
of items of varying lengths.</p>
<p>Still,
it’s a good idea to choose a format that is easily parsable
in most programming languages/environments.
Thus,
over the last years a lot of applications gained the ability
to output their data in <a href="https://www.json.org/">JSON</a>.
It’s simple enough that parsers exist in practically every language
yet powerful enough to be useful in a lot of cases.
While its a text format that can be read by humans,
a lot of people have also worked on implementations that are very fast at
parsing JSON data and serializing data to JSON.</p>
<p>In the description above,
we’ve talked about “messages” being written by our program.
This is a good way of thinking about the output:
Your program doesn’t necessarily only output one blob of data
but may in fact emit a lot of different information
while it is running.
One easy way to support this approach when outputting JSON
is to write one JSON document per message
and to put each JSON document on new line
(sometimes called <a href="https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON">Line-delimited JSON</a>).
This can make implementations as simple as using a regular <code>println!</code>.</p>
<p>Here’s a simple example,
using the <code>json!</code> macro from <a href="https://crates.io/crates/serde_json">serde_json</a>
to quickly write valid JSON in your Rust source code:</p>
<pre><code class="language-rust ignore">use structopt::StructOpt;
use serde_json::json;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(StructOpt)]
struct Cli {
    /// Output JSON instead of human readable messages
    #[structopt(long = &quot;json&quot;)]
    json: bool,
}

fn main() {
    let args = Cli::from_args();
    if args.json {
        println!(&quot;{}&quot;, json!({
            &quot;type&quot;: &quot;message&quot;,
            &quot;content&quot;: &quot;Hello world&quot;,
        }));
    } else {
        println!(&quot;Hello world&quot;);
    }
}
</code></pre>
<p>And here is the output:</p>
<pre><code class="language-console">$ cargo run -q
Hello world
$ cargo run -q -- --json
{&quot;content&quot;:&quot;Hello world&quot;,&quot;type&quot;:&quot;message&quot;}
</code></pre>
<p>(Running <code>cargo</code> with <code>-q</code> suppresses its usual output.
The arguments after <code>--</code> are passed to our program.)</p>
<h3 id="practical-example-ripgrep"><a class="header" href="#practical-example-ripgrep">Practical example: ripgrep</a></h3>
<p><em><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></em> is a replacement for <em>grep</em> or <em>ag</em>, written in Rust.
By default it will produce output like this:</p>
<pre><code class="language-console">$ rg default
src/lib.rs
37:    Output::default()

src/components/span.rs
6:    Span::default()
</code></pre>
<p>But given <code>--json</code> it will print:</p>
<pre><code class="language-console">$ rg default --json
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Output::default()\n&quot;},&quot;line_number&quot;:37,&quot;absolute_offset&quot;:761,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:12,&quot;end&quot;:19}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:137622,&quot;human&quot;:&quot;0.000138s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:6064,&quot;bytes_printed&quot;:256,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Span::default()\n&quot;},&quot;line_number&quot;:6,&quot;absolute_offset&quot;:117,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:10,&quot;end&quot;:17}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:22025,&quot;human&quot;:&quot;0.000022s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:5221,&quot;bytes_printed&quot;:277,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;data&quot;:{&quot;elapsed_total&quot;:{&quot;human&quot;:&quot;0.006995s&quot;,&quot;nanos&quot;:6994920,&quot;secs&quot;:0},&quot;stats&quot;:{&quot;bytes_printed&quot;:533,&quot;bytes_searched&quot;:11285,&quot;elapsed&quot;:{&quot;human&quot;:&quot;0.000160s&quot;,&quot;nanos&quot;:159647,&quot;secs&quot;:0},&quot;matched_lines&quot;:2,&quot;matches&quot;:2,&quot;searches&quot;:2,&quot;searches_with_match&quot;:2}},&quot;type&quot;:&quot;summary&quot;}
</code></pre>
<p>As you can see,
each JSON document is an object (map) containing a <code>type</code> field.
This would allow us to write a simple frontend for <code>rg</code>
that reads these documents as they come in and show the matches
(as well the files they are in)
even while <em>ripgrep</em> is still searching.</p>
<aside>
<p><strong>Aside:</strong>
This is how Visual Studio Code uses <em>ripgrep</em> for its code search.</p>
</aside>
<h2 id="how-to-deal-with-input-piped-into-us"><a class="header" href="#how-to-deal-with-input-piped-into-us">How to deal with input piped into us</a></h2>
<aside class="todo">
<p><strong>TODO:</strong>
Talk about how work with stdin
(see <a href="https://github.com/rust-cli/meta/issues/95">#95</a>)</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为你的-cli-程序生成文档"><a class="header" href="#为你的-cli-程序生成文档">为你的 CLI 程序生成文档</a></h1>
<p>CLI 程序的文档通常包括调用命令时使用 <code>--help</code> 及 <code>man</code> 手册。</p>
<p>当你使用 <code>clap</code> v3（目前还是 unreleased 状态），会通过 <code>man</code> 后端自动生成这些。</p>
<pre><code class="language-rust ignore">#[derive(Clap)]
pub struct Head {
    /// file to load
    #[clap(parse(from_os_str))]
    pub file: PathBuf,
    /// how many lines to print
    #[clap(short = &quot;n&quot;, default_value = &quot;5&quot;)]
    pub count: usize,
}
</code></pre>
<p>其次，你需要使用 <code>build.rs</code> 来在编译时从你的代码中生成手册。</p>
<p>在这里你要留意几件事（比如如何打包你的程序），
但现在我们只是简单地把 <code>man</code> 文件放到我们的 <code>src</code> 同级目录。</p>
<pre><code class="language-rust ignore">use clap::IntoApp;
use clap_generate::gen_manuals;

#[path=&quot;src/cli.rs&quot;]
mod cli;

fn main() {
    let app = cli::Head::into_app();
    for man in gen_manuals(&amp;app) {
        let name = &quot;head.1&quot;;
        let mut out = fs::File::create(name).unwrap();
        use std::io::Write;
        out.write_all(man.render().as_bytes()).unwrap();
    }
}
</code></pre>
<p>现在你编译你的程序时，将在你的项目目录生成一个 <code>head.1</code> 文件。</p>
<p>如果你使用 <code>man</code> 打开它，就可以看到你的文档了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好用的-crates"><a class="header" href="#好用的-crates">好用的 crates</a></h1>
<p>总会有新的可适用于开发命令行工具程序的 crates 被发布出来。</p>
<h2 id="本书引用到的-crates"><a class="header" href="#本书引用到的-crates">本书引用到的 crates</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">anyhow</a> - provides <code>anyhow::Error</code> for easy error handling</li>
<li><a href="https://crates.io/crates/assert_cmd">assert_cmd</a> - simplifies integration testing of CLIs</li>
<li><a href="https://crates.io/crates/assert_fs">assert_fs</a> - Setup input files and test output files</li>
<li><a href="https://crates.io/crates/atty">atty</a> - detected whether application is running in a tty</li>
<li><a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> - adds a <code>--verbose</code> flag to structopt CLIs</li>
<li><a href="https://crates.io/crates/clap">clap</a> - command line argument parser</li>
<li><a href="https://crates.io/crates/confy">confy</a> - boilerplate-free configuration management</li>
<li><a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a> - provides multi-producer multi-consumer channels for message passing</li>
<li><a href="https://crates.io/crates/ctrlc">ctrlc</a> - easy ctrl-c handler</li>
<li><a href="https://crates.io/crates/env_logger">env_logger</a> - implements a logger configurable via environment variables</li>
<li><a href="https://crates.io/crates/exitcode">exitcode</a> - system exit code constants</li>
<li><a href="https://crates.io/crates/human-panic">human-panic</a> - panic message handler</li>
<li><a href="https://crates.io/crates/indicatif">indicatif</a> - progress bars and spinners</li>
<li><a href="https://crates.io/crates/log">log</a> - provides logging abstracted over implementation</li>
<li><a href="https://crates.io/crates/predicates">predicates</a> - implements boolean-valued predicate functions</li>
<li><a href="https://crates.io/crates/proptest">proptest</a> - property testing framework</li>
<li><a href="https://crates.io/crates/serde_json">serde_json</a> - serialize/deserialize to JSON</li>
<li><a href="https://crates.io/crates/signal-hook">signal-hook</a> - handles UNIX signals</li>
<li><a href="https://crates.io/crates/structopt">structopt</a> - parses command line arguments into a struct</li>
<li><a href="https://crates.io/crates/tokio">tokio</a> - asynchronous runtime</li>
<li><a href="https://crates.io/crates/wasm-pack">wasm-pack</a> - tool for building WebAssembly</li>
</ul>
<h2 id="其它-crates"><a class="header" href="#其它-crates">其它 crates</a></h2>
<p>Rust 的 crates 景观是不断变化的，你可以在 <a href="https://lib.rs">lib.rs</a> 查找 crates：
以下是一些可能对构建 CLIs 有用的特定的类别：</p>
<ul>
<li><a href="https://lib.rs/command-line-interface">Command-line interface</a></li>
<li><a href="https://lib.rs/config">Configuration</a></li>
<li><a href="https://lib.rs/database">Database interfaces</a></li>
<li><a href="https://lib.rs/encoding">Encoding</a></li>
<li><a href="https://lib.rs/filesystem">Filesystem</a></li>
<li><a href="https://lib.rs/web-programming/http-client">HTTP Client</a></li>
<li><a href="https://lib.rs/os">Operating systems</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>

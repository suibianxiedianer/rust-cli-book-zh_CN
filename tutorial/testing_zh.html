<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>测试 - Command Line Applications in Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="../src/special-content.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../README_zh.html">让我们开始吧！</a></li><li class="chapter-item expanded "><a href="../tutorial/README_zh.html"><strong aria-hidden="true">1.</strong> 15 分钟编写一个命令行工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/setup_zh.html"><strong aria-hidden="true">1.1.</strong> 初始化项目</a></li><li class="chapter-item expanded "><a href="../tutorial/cli-args_zh.html"><strong aria-hidden="true">1.2.</strong> 解析命令行参数</a></li><li class="chapter-item expanded "><a href="../tutorial/impl-draft_zh.html"><strong aria-hidden="true">1.3.</strong> 第一个实现</a></li><li class="chapter-item expanded "><a href="../tutorial/errors_zh.html"><strong aria-hidden="true">1.4.</strong> 更好地反馈错误</a></li><li class="chapter-item expanded "><a href="../tutorial/output_zh.html"><strong aria-hidden="true">1.5.</strong> 输出</a></li><li class="chapter-item expanded "><a href="../tutorial/testing_zh.html" class="active"><strong aria-hidden="true">1.6.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../tutorial/packaging_zh.html"><strong aria-hidden="true">1.7.</strong> 打包并发布一个 Rust 工具</a></li></ol></li><li class="chapter-item expanded "><a href="../in-depth/README_zh.html"><strong aria-hidden="true">2.</strong> 再深入谈谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../in-depth/signals_zh.html"><strong aria-hidden="true">2.1.</strong> 信号处理</a></li><li class="chapter-item expanded "><a href="../in-depth/config-files_zh.html"><strong aria-hidden="true">2.2.</strong> 使用配置文件</a></li><li class="chapter-item expanded "><a href="../in-depth/exit-code_zh.html"><strong aria-hidden="true">2.3.</strong> 退出状态码</a></li><li class="chapter-item expanded "><a href="../in-depth/human-communication_zh.html"><strong aria-hidden="true">2.4.</strong> 与人交互</a></li><li class="chapter-item expanded "><a href="../in-depth/machine-communication_zh.html"><strong aria-hidden="true">2.5.</strong> 与机器交互</a></li><li class="chapter-item expanded "><a href="../in-depth/docs_zh.html"><strong aria-hidden="true">2.6.</strong> 为你的 CLI 程序生成文档</a></li></ol></li><li class="chapter-item expanded "><a href="../crates/README_zh.html"><strong aria-hidden="true">3.</strong> 好用的 crates</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-cli/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<p>在数十年的软件开发中，人们发现了一个真理：未经测试的软件很难正常工作。
（许多人也会说，经过测试的软件也可能不工作，但我们都是乐观主义者，不是么）
所以，为了确保你的程序可如你预期的那样工作，最好先对其进行测试。</p>
<p>一种简单的方式是在 <code>README</code> 文件中写明你的软件将如何工作。
当你准备好进行一次新的发布时，再过一遍 <code>README</code> 的功能并确定其仍能正常工作。
你还可以写入你的程序如何应对错误的输入，使得这个测试变得更加严格。</p>
<p>另一个绝妙的主意是：在写代码前先写 <code>README</code>。</p>
<aside>
<p><strong>注：</strong>
如果你没听过 <a href="https://zh.wikipedia.org/wiki/Test-driven_development">测试驱动开发</a> (TDD) 那么你最好去看一看它。</p>
</aside>
<h2 id="自动化测试"><a class="header" href="#自动化测试">自动化测试</a></h2>
<p>现在一切都妥了，但如果手动去完成测试，会耗费大量的时间。
现在，人们更喜欢让计算机来协助完成这些工作，下面我们来谈谈自动化测试。</p>
<p>Rust 有内建的测试框架，让我们试着写出一个测试吧：</p>
<pre><code class="language-rust ignore">#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
</code></pre>
<p>你可以把这段代码放在几乎任何文件，<code>cargo test</code> 将运行它。
这里的关键是 <code>#[test]</code> 属性。构建系统会寻找这类函数，并当作测试去运行它们，
确认他们不会出错（panic）。</p>
<aside class="exercise">
<p><strong>练习：</strong>
让这个测试能正常工作。</p>
<p>完成后，测试的输出应该是这样的：</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>现在我们已经了解了如何去编写测试项，那么下一个问题就是要测试什么？
如你所见，为函数写断言非常简单。但 CLI 程序通常不止一个功能函数！
更麻烦的是，它通常要处理用户的输入、读取文件并写入输出。</p>
<h2 id="编写可测试的代码"><a class="header" href="#编写可测试的代码">编写可测试的代码</a></h2>
<p>测试功能有两种互补的方法：
测试构建成完整程序的功能小单元，叫作“单元测试”。
还有就是从外部测试最终的程序，称为“黑盒测试”或“集成测试”。
让我们先从单元测试开始。</p>
<p>为了弄清楚我们要测试什么，让我们先看看我们程序的功能。
<code>grrs</code> 应该打印出，文件中包含符合匹配字符串的行。
所以，让我们给<strong>匹配</strong>功能写一个单元测试：
我们希望确保我们最重要的逻辑部分能正常工作，
并且以一种不依赖于任何需要设置代码、变量的方式实现（比如，处理 CLI 参数）。</p>
<p>回到我们的 <code>grrs</code> 的<a href="impl-draft_zh.html">第一个实现</a>，
当时我们在 <code>main</code> 函数中添加了如下代码块：</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre>
<p>遗憾的是，这样的代码很难测试。
首先，因为它在 <code>main</code> 函数中，所以我们不能简单的直接调用它。
而把这段代码移动到一个函数中，就可以很简单地解决这个问题了：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们可以在测试中调用这个函数了，让我们来看一下它的输出是什么：</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;);
    assert_eq!( // uhhhh
</code></pre>
<p>或者，我们还不能……现在，<code>find_matches</code> 会直接将输出打印到 <code>stdout</code>，比如在终端。
我们不能简单地在测试中捕获它的输出！
这是在实现功能后再编写测试时经常遇到的问题：
我们编写了一个牢固地集成在它所使用的上下文中的函数。</p>
<aside class="note">
<p><strong>注：</strong>
这在编写一个小的 CLI 程序时问题不大。没必要去测试每个功能！
但重要的是要想清楚，哪些代码是需要去编写单元测试的。
虽然下面我们可以轻易的将这个函数修改为可测试的，但事情并非总是如此美好。</p>
</aside>
<p>那么，我们怎样才能让这个函数变得可测呢？我们得能获取它的输出。
Rust 的标准库有一些简单的抽象来处理 I/O，在这里我们将使用 <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>。
这是一个 <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a>，
它可以抽象我们可以写入的事物，包括字符串和标准输出。</p>
<p>如果你是第一次在 Rust 中看到 “trait” 这个词，也没关系。
特性（trait）是 Rust 最强大的特性之一。
你可以把它看成 Java 中的接口，或 Haskell 的 type classes（看你了解哪个）。
它允许你抽象可由不同类型共享的行为。
使用 trait 的代码可以以非常通用和灵活的方式来实现功能，
但这也意味着它可能难以阅读。
但请不要被它吓到：即使是 Rust 中的老手也不一定能马上理解通用代码的作用。
在这种情况下，考虑具体用途会有所帮助。
比如，现在，我们抽象的行为是“写入”。实现了（“impl”）了它的类型有：
终端的标准输出、文件、内存中的缓存或 TCP 网络连接。
（在<a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code> 文档</a> 中下翻可查看实现此 trait 的列表）</p>
<p>有了这些知识，让我们修改函数以便接受第三个参数。它应该是一个实现了 <code>Write</code>
的类型。这样，我们就可以在测试中提供一个简单的字符串并对其进行断言。
这是我们的 <code>find_matches</code> 的新版本：</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, &quot;{}&quot;, line);
        }
    }
}
</code></pre>
<p>第三个参数是 <code>mut writer</code>，即一个名为 <code>writer</code> 的可变变量。
它的类型是 <code>impl std::io::Write</code>，你可理解为“实现了 <code>Write</code> trait 的任意类型”。
还要注意，我们使用 <code>writeln!(writer, …)</code> 替换了之前的 <code>println!(…)</code>。
<code>println!</code> 的行为类似于 <code>writeln!</code>，只不过它总是写入到标准输出里。</p>
<p>现在我们可以测试它的输出了：</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;, &amp;mut result);
    assert_eq!(result, b&quot;lorem ipsum\n&quot;);
}
</code></pre>
<p>现在我们必须修改 <code>main</code> 函数中对 <code>find_matches</code> 的调用，给它加
<a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a> 作为第三个参数。
下面是修改完成之后，使用新版 <code>find_matches</code> 的 <code>mian</code> 函数：</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::from_args();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!(&quot;could not read file `{}`&quot;, args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}
</code></pre>
<aside class="note">
<p><strong>注：</strong>
由于 <code>stdout</code> 接收的是字节（而不是字符串）,
所以我们使用 <code>std::io::Write</code> 而不是 <code>std::fmt::Write</code>。
因此，我们在测试中传入了一个空的 vector 作为 “writer”
（它会被判断为 <code>Vec&lt;u8&gt;</code>），在 <code>assert_eq</code> 中我们使用 <code>b&quot;foo&quot;</code>。
（<code>b</code> 使得它被当作 <em>byte 字节</em>，即其类型为 <code>&amp;[u8]</code> 而非 <code>&amp;str</code>。</p>
</aside>
<aside class="note">
<p><strong>注：</strong>
我们也可以让这个函数（<code>find_matches</code>）返回一个 <code>String</code>，
但这样就改变了它的行为。即它不会直接将结果写入终端，
而是将所有的匹配行收集为一个字符串，并在最后返回一个结果。</p>
</aside>
<aside class="exercise">
<p><strong>练习：</strong>
<a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a> 返回值是 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a>，因为写入可能会失败，
例如缓存被用尽又无法申请新空间时。
请在 <code>find_matches</code> 添加上错误处理。</p>
</aside>
<p>我们刚刚学习了如何使一段代码变得易于测试。我们做了：</p>
<ol>
<li>找到程序中的一段核心代码，</li>
<li>将它封装到一个独立的函数中，</li>
<li>让它的使用方法变得更为灵活。</li>
</ol>
<p>尽管我们的目标仅仅是让它具有可测试性，
但我们最终得到了一段符合 Rust 语言风格且可被复用的代码，这非常棒！</p>
<h2 id="将代码拆分为库和二进制"><a class="header" href="#将代码拆分为库和二进制">将代码拆分为库和二进制</a></h2>
<p>这里我们还需要做一些事情。到目前为止我们将所有的代码写到了 <code>src/main.rs</code> 里。
这意味着我们的项目只会编译成一个单独的二进制程序。
但我们也可以将我们的代码作为库提供，像这样：</p>
<ol>
<li>将 <code>find_matches</code> 函数放到新的 <code>src/lib.rs</code> 文件中。</li>
<li>在函数名前（<code>fn</code>）添加上 <code>pub</code> 标记（现在函数为 <code>pub fn find_matches</code>）
以便这个库的使用者可以访问这个函数。</li>
<li>将 <code>src/main.rs</code> 中的 <code>find_matches</code> 函数移除。</li>
<li>在 <code>fn main</code> 中使用 <code>grrs::find_matches</code> 去调用我们在库中的 <code>find_matches</code>
函数。</li>
</ol>
<p>Rust 处理项目的方式非常灵活，尽早地考虑清楚哪些功能要放到库中是个好主意。
例如，你可以考虑先为用于特定程序的逻辑编写一个库，然后像调用任意其它库一样，
在你的 CLI 程序中使用它。又或者，若你的项目会生成多个二进制程序，
你可以将其通用的功能放到库里，提高代码的复用性。</p>
<aside class="note">
<p><strong>注：</strong>
如果将所有的代码都放到 <code>src/main.rs</code> 里，这会让我们的代码变得难以阅读。
查看 <a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">module system</a> 可以帮助你去构建、组织你的代码结构。</p>
</aside>
<h2 id="通过运行-cli-程序来测试它们"><a class="header" href="#通过运行-cli-程序来测试它们">通过运行 CLI 程序来测试它们</a></h2>
<p>到目前为止，我们已经测试了我们程序中的_业务逻辑_，即 <code>find_matches</code> 函数。
这是非常有价值的，并且是迈向实现经过良好测试的代码的第一步。
（通常，这类测试被称为“单元测试”）</p>
<p>但还有许多代码是我们没有测试到的，因为：
我们写的一切都是为了与外界打交道！
想像一下，在你写 <code>main</code> 函数时，不小心留下了一段硬编码的路径字符串，
软件运行时会使用它而非用户提供的参数！
我们也需要编写这类的测试！（这个级别的测试一般被称为“集成测试”或“系统测试”）</p>
<p>从本质上讲，我们仍要编写函数并使用 <code>#[test]</code> 注释它们。
现在的问题是我们要在这些函数中做什么？
例如，我们想像运行一个普通程序一样使用我们项目的主程序。
我们还要将这些测试放入到一个全新的路径下：<code>tests/cli.rs</code>。</p>
<aside>
<p><strong>注：</strong>
依约定，<code>cargo</code> 会在 <code>tests/</code> 目录中查找集成测试。
同样，它会在 <code>benches/</code> 目录寻找 benchmarks，在 <code>examples/</code> 中寻找示例。
这些约定也扩展到你的主要源代码：
库有一个 <code>src/libs.rs</code> 文件，主程序是 <code>src/main.rs</code>，
如果这里有多个二进制程序，<code>cargo</code> 期望它们放在 <code>src/bin/&lt;name&gt;.rs</code> 中。
遵循这些约定可以让你的代码对于习惯阅读 Rust 代码的人更为友好。</p>
</aside>
<p>回想一下，<code>grrs</code> 是一个在文件中搜索字符串的小工具。
我们已经测试过了查找匹配项功能。让我们再想想还能测试哪些功能。</p>
<p>这里我想到了一些。</p>
<ul>
<li>如果文件不存在会怎样？</li>
<li>当没有搜索到匹配项时返回什么？</li>
<li>当我们少写一个（或都没写）参数时，我们的程序会以错误状态退出？</li>
</ul>
<p>这些都是有效的测试用例。
此外，我们还应该有一个成功的测试用例，即程序正常运行且找到至少一个匹配并打印。</p>
<p>为了让这类的测试更容易，我们将使用到 <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> 箱。
它提供了许多简洁的帮助程序，可以让我们运行我们的主程序并查看它的行为。
此外，我们还将添加 <a href="https://docs.rs/predicates"><code>predicates</code></a> 箱，
来帮助我们为 <code>assert_cmd</code> 的测试项编写断言（且具有很棒的错误消息）。
我们不会将这些依赖放到程序的主依赖中，
而是放到 <code>Cargo.toml</code> 的 <code>dev dependencies</code> 部分。
它们只会在开发时被使用到，而使用时则不会。</p>
<pre><code class="language-toml">
[dependencies]
structopt = &quot;0.3.22&quot;
</code></pre>
<p>设置完成后，让我们来创建我们的 <code>tests/cli.rs</code> 文件：</p>
<pre><code class="language-rust ignore">use assert_cmd::prelude::*; // Add methods on commands
use predicates::prelude::*; // Used for writing assertions
use std::process::Command; // Run programs

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;

    cmd.arg(&quot;foobar&quot;).arg(&quot;test/file/doesnt/exist&quot;);
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;No such file or directory&quot;));

    Ok(())
}
</code></pre>
<p>你可以像我们之前做测试时一样，通过运行 <code>cargo test</code> 来运行这个测试。
在第一次运行时可能会稍慢，因为我们要编译出项目的主程序，它在
<code>Command::cargo_bin(&quot;grrs&quot;)</code> 被调用。</p>
<h2 id="生成测试文件"><a class="header" href="#生成测试文件">生成测试文件</a></h2>
<p>我们刚编写的测试，只会在检查我们的程序的输入的文件参数不存在时输出的错误信息。
这是很重要的一个测试项，却不是最重要的：
让我们测试下，正确运行程序并打印出文件中匹配项的用例。</p>
<p>首先我们要有一个已知内容的文件，这样我们才能确认正确的输出是什么从而进行测试。
当然我们可以在项目中添加一个文件专门用来进行测试，或者也可以创建临时文件来测试。
在本教程中，我们选择后面一种做法。因为它相对更为灵活且也适用于其它测试用例；
比如，当你要测试去修改一个文件的时候。</p>
<p>为了生成这些临时文件，我们要使用到 <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a> 箱，
让我们把它添加到 <code>Cargo.toml</code> 的 <code>dev-dependencies</code> 中。</p>
<pre><code class="language-toml">anyhow = &quot;1.0&quot;
</code></pre>
<p>这就是新的测试用例，首先去创建一个临时文件（并获取到它的路径），
然后在里面填充一些内容，再去运行我们的程序来检查我们能否获得正确的输出。
当执行完这个代码后，<code>file</code> 将自动被删除。</p>
<pre><code class="language-rust ignore">use assert_fs::prelude::*;

#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new(&quot;sample.txt&quot;)?;
    file.write_str(&quot;A test\nActual content\nMore content\nAnother test&quot;)?;

    let mut cmd = Command::cargo_bin(&quot;grrs&quot;)?;
    cmd.arg(&quot;test&quot;).arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains(&quot;test\nAnother test&quot;));

    Ok(())
}
</code></pre>
<aside class="exercise">
<p><strong>练习：</strong>
添加一个传入的匹配项为空字符串的集成测试，并按需去调整程序。</p>
</aside>
<h2 id="去测试什么"><a class="header" href="#去测试什么">去测试什么？</a></h2>
<h2 id="what-to-test"><a class="header" href="#what-to-test">What to test?</a></h2>
<p>虽然编写集成测试很有意思，但毕竟编写测试是要消耗时间的，
而且当你的程序行为有所变动时可能也需要去更新这些测试。
为了让我们花费的时间变得更有意义，我们应该问下自己，我们要测试什么？</p>
<p>一般来讲，为用户可以观察到的所有类型的行为编写集成测试是一个好主意。
这意味着你不需要去涵盖所有的边界情况：通常会有不同类型的示例，
再依赖于单元测试即可覆盖边界情况。</p>
<p>同样，尝试去测试你不能掌控的东西，并不是一个好主意。
测试 <code>--help</code> 的确切输出布局，会是一个坏主意，
相反，你可能只想检查其中某些元素是否存在。</p>
<p>根据程序的特性，你还可以尝试添加更多的测试技术。
比如，当你尝试去测试到所有的边界情况时，如果你提取了你程序的一部分，
并且发现你已经写了许多作为单元测试的示例情景，你可以看看 <a href="https://docs.rs/proptest"><code>proptest</code></a>。
如果你的程序会使用任意一个文件并解析它们，请试着写一个 <a href="https://rust-fuzz.github.io/book/introduction.html">fuzzer</a>
来查找边界条件下的 bugs。</p>
<aside>
<p><strong>注：</strong>
你可以在<a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">这里</a> 看到完整、可运行的源码。</p>
</aside>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../tutorial/output_zh.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../tutorial/packaging_zh.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../tutorial/output_zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../tutorial/packaging_zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
